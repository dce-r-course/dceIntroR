# Covariates

In this session, we will explore how we can identify covariates for our MI patients!

## Make a script

First, make a script where we can save our code. Choose either R Markdown/Quarto or R Script.

Name it "covariates".

Save it in the folder "R".

## Load packages

Load the packages we will need under a section called "Load packages".

```{r, message=FALSE, warning = FALSE}

library(tidyverse)
library(purrr)

```

We will introduce the `purrr` package, so we should add this as a workflow dependency

```{r, eval = FALSE}
usethis::use_package("purrr")
```

## Load the datasets

Load the datasets we will need under a section called "Load data"

```{r, warning = FALSE, message = FALSE}

basic_data <- readRDS(here::here("data_raw/basic_data.rds"))

diag_data <- readRDS(here::here("data_raw/diag_data.rds"))

data_pop_mi <- readRDS(here::here("data/data_pop_mi.rds"))


```

## Choose covariates

First, we must decide which covariates we would like to include.

From `basic_data`:

-   age

-   sex

From `diag_data`:

-   Hypertension

-   Hypercholesterolaemia

-   Diabetes

-   Heart failure

### Age and sex

In the `basic_data`, we can obtain information on age ans sex from the variables `birth_date` and `sex`.

```{r, warning = FALSE, message = FALSE}
data_cov_01 <- data_pop_mi |> 
  left_join(basic_data |> select(id, birth_date, sex),
            by = "id")

data_cov_01

```

Now, we can calculate age at admission

```{r, warning = FALSE, message = FALSE}
data_cov_02 <- data_cov_01 |> 
  mutate(
    age = round(as.numeric(index_date - birth_date)/365.25,0)
  )

data_cov_02
```

::: {.callout-note collapse="true"}
**Explanation**

-   `round()`: specifies the number of digits

-   `as.numeric()`: specifies that the difference between `index_date` and `birth_date` should be a numeric value, which allows us to divide by 365.25 to obtain age in years.
:::

#### Normal distributed

Let's have a look at whether the age distribution of our MI patients follow a normal distribution. And let's see if it differs between sex.

For this, we will be using `ggplot2.`

##### What is `ggplot2`?

`ggplot2` is a system for creating graphics based on the **Grammar of Graphics** — a structured way of thinking about and building plots. Instead of using one function to create a plot all at once, you build your plot step by step by adding layers.

This makes your code more readable, flexible, and easier to modify.

A `ggplot2` plot always starts with the `ggplot()` function. Then you add layers using the **`+`** operator.

Here’s the basic structure:

```{r, eval = FALSE}

data |> 
  ggplot(aes(x = x_variable, y = y_variable)) +
  geom_function()

```

Let’s break that down:

-   `data`: Specify which data we will be using
-   `ggplot()`: This sets up the plot.
-   `aes():` Short for aesthetics — this is where you define what goes on the x- and y-axes (and optionally color, size, shape, etc.).
-   `geom_*()`: These are the layers that define *how* the data should be visualised — for example:
    -   `geom_point()` for scatter plots

    -   `geom_bar()` for bar charts

    -   `geom_line()` for line plots

    -   `geom_histogram()` for histograms

Let's see if the age distribution is normally distributed and stratify by sex.

##### QQ plot

```{r, warning = FALSE, message = FALSE}

data_cov_02 |> 
  mutate(sex = factor(sex, levels = c(1,2), labels = c("Male", "Female"))) |> 
  ggplot(aes(sample = age, group = sex, color = sex, fill = sex)) + 
  geom_qq() + 
  geom_qq_line() + 
  facet_wrap(~sex) + 
  ggsci::scale_fill_nejm() + 
  ggsci::scale_color_nejm() + 
  theme_bw()

```

::: {.callout-note collapse="true"}
**Explanation**

-   `mutate(sex = factor(...))`

    Converts the numeric sex variable (1/2) into a labeled factor with levels "Male" and "Female" — making the plot more interpretable.

-   `ggplot(aes(...))`

    Initialises a ggplot object using age as the variable to be plotted in a Q-Q plot.

    -   sample = age: Specifies the variable to be compared against a theoretical normal distribution.

    -   group = sex: Ensures separate Q-Q plots are generated for each sex group.

    -   color and fill: Assign colors based on sex.

-   `geom_qq()`

    Adds a Q-Q plot layer — this visualizes how the distribution of age compares to a normal distribution.

-   `geom_qq_line()`

    Adds a reference line to the Q-Q plot — if the data follows a normal distribution, points should lie close to this line.

-   `facet_wrap(~sex)`

    Creates separate plots for "Male" and "Female" — allowing for side-by-side comparison of age distributions.

-   `ggsci::scale_fill_nejm()` and `ggsci::scale_color_nejm()`

    Applies a color palette inspired by the *New England Journal of Medicine*.

    Note, here we call the functions directly from the `ggsci` package. We could also load the package under "Load packages". That will largely depend on how frequently we will use it, and whether it conflicts with other packages. But, we should add it as a workflow-dependency package in our `DESCRIPTION` file.

    ```{r, eval = FALSE}

    usethis::use_package("ggsci")

    ```

-   `theme_bw()`

    Applies a minimal black-and-white theme — removes background shading and grid clutter for a cleaner appearance. There are tons of themes you can use. Moreover, using the `theme()` function, you can customise your layout intensively.
:::

##### Histogram

```{r, warning = FALSE, message = FALSE}

data_cov_02 |> 
  mutate(sex = factor(sex, levels = c(1, 2), labels = c("Male", "Female"))) |> 
  ggplot(aes(x = age, group = sex, color = sex, fill = sex)) + 
  geom_histogram(aes(y = after_stat(density)), alpha = .25) +
  stat_function(fun=dnorm, args = list(mean = mean(data_cov_02$age), sd = sd(data_cov_02$age)), linewidth = .75) + 
  facet_wrap(~ sex) +
  ggsci::scale_fill_nejm() + 
  ggsci::scale_color_nejm() +
  theme_bw()

```

::: {.callout-note collapse="true"}
**Explanation**

-   `mutate(sex = factor(...))`

    Converts the numeric sex variable (1 = Male, 2 = Female) into a labeled factor for clearer plotting and legend labels.

-   `ggplot(aes(...))`

-   Initializes the plot using age as the x-axis variable.

    -   group = sex: Ensures separate density curves per sex.

    -   color and fill: Assign colors based on sex for visual distinction.

-   `geom_histogram(aes(y = ..density..), alpha = .25)`\
    Plots a histogram of the age variable, scaled to show density rather than raw counts.

    -   alpha = .25: Makes the bars semi-transparent so overlapping areas are visible.

-   `stat_function(fun = dnorm, ...)`

    Adds a normal distribution curve over the histogram using the overall mean and standard deviation of age.

    -   This helps visually compare the actual age distribution to a theoretical normal distribution.

-   `facet_wrap(~ sex)`\
    Creates separate panels for "Male" and "Female" — allowing side-by-side comparison of age distributions.

`ggsci::scale_fill_nejm()` and `ggsci::scale_color_nejm()`

Applies a color palette inspired by the *New England Journal of Medicine*.

Note, here we call the functions directly from the `ggsci` package. We could also load the package under "Load packages". That will largely depend on how frequently we will use it, and whether it conflicts with other packages. But, we should add it as a workflow-dependency package in our `DESCRIPTION` file.

-   `theme_bw()`

    Applies a minimal black-and-white theme — removes background shading and grid clutter for a cleaner appearance. There are tons of themes you can use. Moreover, using the `theme()` function, you can customise your layout intensively.
:::

### Comorbidities

The `diag_data` contains the following diseases and codes.

| Comorbidity | ICD-10 code |
|----|----|
| Myocardial infarction | DI21 |
| Hypertension | DI10, DI11, DI12, DI13, DI14, DI15 |
| Hypercholesterolaemia | DE78 |
| Diabetes | DE10, DE11, DE12, DE13, DE14 |
| Heart failure | DI50 |
| Random | DX01, DX02, DX03, DX04, DX05, DX06, DX07, DX08, DX09 |

: Comorbidities and ICD-10 codes

There are several different ways to identify comorbidities. Here, we will go over a couple.

We set some assumptions.

1.  We do not include information on diagnoses recorded during index admission
2.  We include diagnoses recorded within 10 years from the index date (*i.e.*, 10 years lookback)
3.  We include diagnoses from both inpatient and outpatient hospital contacts
4.  We include diagnoses recorded as either a primary and a secondary diagnosis.
5.  We apply the same assumptions for all comorbidities.

### Baseline, identify, add

One approach is to

#### Step 1. 

1.  Define a baseline study pop set

```{r, warning = FALSE, message = FALSE}

data_baseline_mi <- data_pop_mi |> 
  select(id, index_date)
```

#### Step 2. 

1.  Add `diag_data` to our new `data_baseline_mi`

2.  Keep only diagnoses recorded before index date and after lookback period

3.  Then we have our basic dataset with all preadmission hospital contacts

```{r, warning = FALSE, message = FALSE}

lookback_years <- 10

lookback <- lookback_years*-1

data_cov_diag <- data_baseline_mi |> 
  left_join(diag_data, by = "id") |> 
  mutate(
    diff = as.numeric(adm_date - index_date) # can also be switched, then adjust definition of lookback
  ) |> 
  filter(
    diff < 0,
    diff > 365.25*lookback
  ) |> 
  select(-diff)

data_cov_diag
```

#### Step 3. 

Identify a given covariate. Let's begin with hypertension.

```{r, warning = FALSE, message = FALSE}

hypertension_code <- c("DI1[0-5]")

cov_hypertension <- data_cov_diag |> 
  mutate(
    hypertension = 
      case_when(
        grepl(hypertension_code, diag_a) | grepl(hypertension_code,diag_b) ~ 1,
        .default = 0
      )) |> 
  filter(hypertension == 1) |> 
  select(id, hypertension) |> 
  distinct()
```

#### Step 4. 

Add the covariate to the baseline and replace `NA` with `0`

```{r, warning = FALSE, message = FALSE}
data_baseline_mi <- 
  data_baseline_mi |> 
  left_join(cov_hypertension, by = "id") |> 
  mutate(hypertension = replace_na(hypertension, 0))
```

#### Step 5. 

Repeat the same procedure for hypercholesterolaemia

```{r, warning = FALSE, message = FALSE}

hyperchol_code <- "DE78"

cov_hyperchol <- data_cov_diag |> 
  mutate(
    hyperchol = 
      case_when(
        grepl(hyperchol_code, diag_a) | grepl(hyperchol_code,diag_b) ~ 1,
        .default = 0
      )) |> 
  filter(hyperchol == 1) |> 
  select(id, hyperchol) |> 
  distinct()

data_baseline_mi <- 
  data_baseline_mi |> 
  left_join(cov_hyperchol, by = "id") |> 
  mutate(hyperchol = replace_na(hyperchol, 0))

data_baseline_mi
```

#### Step 6. 

Keep on repeating..

While this do work, it gets slightly redundant — and we are repeating ourselves a lot!

Let's explore a different approach using functions and loops.

We begin by tidying our environment.

```{r}
rm(data_baseline_mi, data_cov_diag, cov_hyperchol, cov_hypertension, hypertension_code, hyperchol_code)
```

### Function based

As the number of comorbidities grows, repeating the same code for each one becomes inefficient and hard to maintain. A more efficient and slightly advanced approach is to:

-   Create a **baseline dataset** with one row per patient containing only `id` and `index_date`

-   Add preadmission hospital contacts to get a dataset like our `data_cov_diag`

-   Define a **comorbidity table** with comorbidity names and ICD-10 patterns

-   Write a **function** that identifies patients who has a history with a given comorbidity

-   Use `for loop` to apply the function over several comorbidities and combine the results into a single dataset

This method is scalable, readable, and easy to adapt to new comorbidities.

#### Step 1. 

Make a baseline dataset onto which we will add covariate indicators

```{r, warning = FALSE, message = FALSE}

data_covariate_mi <- data_pop_mi |> 
  select(id, index_date)


data_cov_diag <- data_covariate_mi |>
  left_join(diag_data, by = "id") |> 
  mutate(
    diff = as.numeric(adm_date - index_date) # can also be switched, then adjust definition of lookback
  ) |> 
  filter(
    diff < 0,
    diff > 365.25*lookback
  ) |> 
  select(-diff)
```

#### Step 2. 

Make a list of diseases and their corresponding codes

Then we list the diseases of interest and their ICD-10 codes in a vector. This can also be an Excel-file you prepare and load into `R`.

```{r, warning = FALSE, message = FALSE}
comorbidity_definitions <- 
  tibble::tibble(
  name = c("hypertension", "hypercholesterolaemia", "diabetes", "heart_failure"),
  pattern = c("DI1[0-5]", "DE78", "DE1[0-4]", "DI50")
)

comorbidity_definitions
```

#### Step 3. 

Make a function

1.  We first `print` the name of the covariate. This help us keeping track on the progress.

2.  We then set the code pattern to be used. We simply extract the code related to the covariate as defined in our `comorbidity_definions` data.

3.  We then identify whether a given contact has a record with the disease of interest.

4.  We then only keep relevant contacts and keep id and the covariate indicator.

5.  Finally, we return the specific dataset containing the covariate indicator.

```{r, warning = FALSE, message = FALSE}

identify_comorbidity <- function(data, disease_name) {
  
  # step 01
  print(disease_name)
  
  # step 02
  code <- comorbidity_definitions$pattern[comorbidity_definitions$name == disease_name]
  
  cov_data <- data |> 
    
    # step 03
    dplyr::mutate(
      {{ disease_name }} := dplyr::case_when(
        grepl(code, diag_a) | grepl(code, diag_b) ~ 1,
        .default = 0
      )
    ) |> 
    
    # step 04
    dplyr::filter(get({{disease_name}}) == 1) |> 
    dplyr::select(id, {{disease_name}}) |> 
    dplyr::distinct()
  
  # step 05
  return(cov_data)
  
}

```

#### Step 4. 

Apply the function using a `for loop`

Essentially, the `for loop` runs the function above for each disease name in our `comorbidity_definition` dataset. It then adds the covariate indicator to `data_covariate_mi`.

```{r, warning = FALSE, message = FALSE}

for (disease_name in comorbidity_definitions$name) {
  
  output <- identify_comorbidity(
    data = data_cov_diag,
    disease_name = disease_name)
  
  data_covariate_mi <- dplyr::left_join(data_covariate_mi, output, by = "id") |> 
    dplyr::distinct()
  
}


```

#### Step 5. 

Combine with age and sex

1.  Combine information on age and sex with the covariate data to get a full baseline dataset.

2.  Then, we replace `NA` with `0` for the covariate dummy variables. We could write out each covariate name, but we might as well be lazy and get some help from the `comorbidity_definitons` dataset :-)

```{r, warning = FALSE, message = FALSE}

data_baseline_mi <- 
  data_cov_02 |> 
  left_join(data_covariate_mi, by = c("id", "index_date")) 

covariates <- paste0(comorbidity_definitions$name)

data_baseline_mi <- data_baseline_mi |> 
  mutate(
    across(c(
           covariates
           ),
           ~ replace_na(.x, 0)
  )
  )

data_baseline_mi
```

## Save

Save the `data_covariates_mi` dataset in the folder `data.`

```{r, warning = FALSE, message = FALSE}

saveRDS(data_baseline_mi, here::here("data/data_baseline_mi.rds"))

```

## Clear environment

```{r, message=FALSE, warning=FALSE, echo = FALSE}

rm(list=ls()) # clears your working environment

gc() # free unused memory

```
