[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to R for Registry-Based Health Research",
    "section": "",
    "text": "Welcome\nThis course is intended to serve as a beginner’s guide to help you get started using R for data management, analysis, and visualisation in health research.\n\n\nAttention\nThis course is based on the initiative of happy amateurs. Therefore, the approaches to data management and visualisations may not reflect the most “correct”, efficient, or elegant way, but are intended only to serve as a way to help you get started with R.\n\n\nAcknowledgements\nThe setup and content of this course draw inspiration from the excellent and more comprehensive courses developed by rostools\n\nIntro Reproducible Research in R\nIntermediate Reproducible Research in R\nAdvanced Intermediate Reproducible Research in R",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "05_loading_management.html",
    "href": "05_loading_management.html",
    "title": "5  Loading, explore, wrangle",
    "section": "",
    "text": "5.1 Make a file\nGenerate an R Script or R Markdown file.\nName it “loading_management”.\nSave it in the R folder.",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Loading, explore, wrangle</span>"
    ]
  },
  {
    "objectID": "05_loading_management.html#load-packages",
    "href": "05_loading_management.html#load-packages",
    "title": "5  Loading, explore, wrangle",
    "section": "5.2 Load packages",
    "text": "5.2 Load packages\nBefore working with data, we load the packages we will use. For now, we will primarily use the tidyverse package (which includes several packages such as dplyr, readr, ggplot2, etc.).\n\n\nCode\nlibrary(tidyverse)",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Loading, explore, wrangle</span>"
    ]
  },
  {
    "objectID": "05_loading_management.html#loading-data",
    "href": "05_loading_management.html#loading-data",
    "title": "5  Loading, explore, wrangle",
    "section": "5.3 Loading data",
    "text": "5.3 Loading data\nData can be stored in many different file formats. Each format has advantages and disadvantages — for instance, some are faster to read, while others better preserve variable types.\nWhen working in R, using .rds or .RData files is often more efficient than formats like .csv or .xlsx.\n.rds files store a single R object (like a data frame) and preserve its structure, including variable types, factor levels, and attributes. This means you don’t need to re-specify column types or re-clean the data after loading. Moreover, you can save objects (like a model fit) in .rds format, which can be very handy if you’ve run a computationally heavy model. .RData files can store multiple R objects in one file. When you load an .RData file, all saved objects are restored into your environment.\nThese formats are:\n\nFast to read and write\nCompact in size\nNative to R, meaning fewer surprises when loading\n\nIn contrast, formats like .csv are plain text and don’t preserve metadata — so you often need to re-define variable types (e.g., dates, factors) after loading.\nUse .rds when you want to save and load a single object.\nUse .RData when you want to save multiple objects together.\nHowever, you will need toknow how to load different file formats.\nHere’s some quick examples on how to read different formats.\n\n\nCode\n#---- .rds\ndata.rds &lt;- readRDS(\"path_to_my_file/data.rds\")\n\n#---- .RData\n\n#---- .csv\ndata.csv &lt;- readr::read_csv(\"path_to_my_file/data.csv\")\ndata.csv &lt;- vroom::vroom(\"path_to_my_file/data.csv\")\n\n#---- .excel\ndata.excel &lt;- readxl::read_excel(\"path_to_my_file/data.xlsx\")\n\n#---- .sas7bdat\ndata.sas &lt;- haven::read_sas(\"path_to_my_file/data.sas7bdat\")\n\n#---- Stata\ndata.stata &lt;- haven::read_dta(\"path_to_my_file/data.dta\")",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Loading, explore, wrangle</span>"
    ]
  },
  {
    "objectID": "05_loading_management.html#download-data",
    "href": "05_loading_management.html#download-data",
    "title": "5  Loading, explore, wrangle",
    "section": "5.4 Download data",
    "text": "5.4 Download data\nPITCH: Here we need to make a link to download basic_data and diag_data on the github page. We will skip that to later.",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Loading, explore, wrangle</span>"
    ]
  },
  {
    "objectID": "05_loading_management.html#load-basic_data-and-diag_data",
    "href": "05_loading_management.html#load-basic_data-and-diag_data",
    "title": "5  Loading, explore, wrangle",
    "section": "5.5 Load basic_data and diag_data",
    "text": "5.5 Load basic_data and diag_data\n\n\nCode\nbasic_data &lt;- readRDS(here::here(\"data_raw/basic_data.rds\"))\n\ndiag_data &lt;- readRDS(here::here(\"data_raw/diag_data.rds\"))",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Loading, explore, wrangle</span>"
    ]
  },
  {
    "objectID": "05_loading_management.html#explore-data",
    "href": "05_loading_management.html#explore-data",
    "title": "5  Loading, explore, wrangle",
    "section": "5.6 Explore data",
    "text": "5.6 Explore data\n\n5.6.1 Quick overview\n\n5.6.1.1 dim()\nThe base function dim returns (1) the number of rows; (2) the number of columns.\n\n\nCode\ndim(basic_data)\n\n\n[1] 1000000       4\n\n\n\n\nCode\ndim(diag_data)\n\n\n[1] 2840870       6\n\n\n\n\n5.6.1.2 colnames()\nWe can easily explore which columns each dataset contains using the base function colnames().\n\n\nCode\ncolnames(basic_data)\n\n\n[1] \"id\"         \"birth_date\" \"death_date\" \"sex\"       \n\n\n\n\nCode\ncolnames(diag_data)\n\n\n[1] \"id\"           \"contact_type\" \"adm_date\"     \"dis_date\"     \"diag_a\"      \n[6] \"diag_b\"      \n\n\nWe prefer to work with variables in lowercase/snakecase. If that was not the case, it is fairly simple to change:\n\n\nCode\ncolnames(data) &lt;- tolower(colnames(data))\n\n\n\n\n5.6.1.3 head()/tail()\nYou can also get a quick overview of the first/last n number of rows using head or tail.\nLet’s look at the basic_data\n\n\nCode\nhead(basic_data, 10)\n\n\n   id birth_date death_date sex\n1   1 1933-01-01       &lt;NA&gt;   1\n2   2 1971-01-01       &lt;NA&gt;   1\n3   3 1997-01-01       &lt;NA&gt;   1\n4   4 1958-01-01       &lt;NA&gt;   1\n5   5 1969-01-01       &lt;NA&gt;   2\n6   6 1960-01-02       &lt;NA&gt;   1\n7   7 1993-01-01       &lt;NA&gt;   2\n8   8 1936-01-02 2023-09-09   2\n9   9 2000-01-02       &lt;NA&gt;   2\n10 10 1989-01-01       &lt;NA&gt;   1\n\n\n… and the diag_data\n\n\nCode\nhead(diag_data,10)\n\n\n# A tibble: 10 × 6\n   id    contact_type adm_date   dis_date   diag_a diag_b\n   &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;  &lt;chr&gt; \n 1 1     1            2013-08-18 2013-08-22 DI12   DI10  \n 2 1     2            2013-11-10 2013-11-10 DX06   DE13  \n 3 2     2            2011-02-24 2011-02-24 DE13   DI14  \n 4 2     2            2014-04-30 2014-04-30 DI15   DE13  \n 5 3     1            2018-07-10 2018-07-12 DI50   DX08  \n 6 3     1            2018-07-10 2018-07-12 DI50   DX01  \n 7 3     2            2021-04-25 2021-04-25 DX03   DX04  \n 8 3     1            2024-07-20 2024-07-25 DX08   DI50  \n 9 4     2            2014-09-27 2014-09-27 DI12   DX06  \n10 4     2            2018-12-08 2018-12-08 DX08   DI15  \n\n\n\n\n5.6.1.4 glimpse()\nglimpse is a function from the dplyr package. In contrast to head/tail, glimpse runs columns down the page and data runs across. This can be helpful if your dataset contains several variables.\n\n\nCode\nglimpse(basic_data)\n\n\nRows: 1,000,000\nColumns: 4\n$ id         &lt;fct&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ birth_date &lt;date&gt; 1933-01-01, 1971-01-01, 1997-01-01, 1958-01-01, 1969-01-01…\n$ death_date &lt;date&gt; NA, NA, NA, NA, NA, NA, NA, 2023-09-09, NA, NA, NA, NA, NA…\n$ sex        &lt;fct&gt; 1, 1, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 1, 1, 1, 1, 2,…\n\n\n\n\nCode\nglimpse(diag_data)\n\n\nRows: 2,840,870\nColumns: 6\n$ id           &lt;fct&gt; 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 6, 7, 7, 7, …\n$ contact_type &lt;fct&gt; 1, 2, 2, 2, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, …\n$ adm_date     &lt;date&gt; 2013-08-18, 2013-11-10, 2011-02-24, 2014-04-30, 2018-07-…\n$ dis_date     &lt;date&gt; 2013-08-22, 2013-11-10, 2011-02-24, 2014-04-30, 2018-07-…\n$ diag_a       &lt;chr&gt; \"DI12\", \"DX06\", \"DE13\", \"DI15\", \"DI50\", \"DI50\", \"DX03\", \"…\n$ diag_b       &lt;chr&gt; \"DI10\", \"DE13\", \"DI14\", \"DE13\", \"DX08\", \"DX01\", \"DX04\", \"…",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Loading, explore, wrangle</span>"
    ]
  },
  {
    "objectID": "05_loading_management.html#choose-your-language",
    "href": "05_loading_management.html#choose-your-language",
    "title": "5  Loading, explore, wrangle",
    "section": "5.7 Choose your language",
    "text": "5.7 Choose your language\nIn R, there are different “languages” or styles of coding for data management. Here are three common ones:\n\nBase R This is the original way of working with data in R. It’s powerful but can be verbose and harder to read.\ndata.table A high-performance package for large datasets. It’s fast and memory-efficient, but has a steeper learning curve and a unique syntax.\ndplyr (part of tidyverse) A modern and readable way to manage data.\nIt uses intuitive verbs like select, filter, and mutate to describe what you want to do.\n\nWhy we use dplyr in this course:\n\nEasy to read and write\nCode is transparent and step-by-step structured\nWidely used in health research and data science\nActively maintained and developed by the R Studio team\n\nFor beginners, dplyr is a great starting point — and it scales well as your skills grow.",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Loading, explore, wrangle</span>"
    ]
  },
  {
    "objectID": "05_loading_management.html#dplyr",
    "href": "05_loading_management.html#dplyr",
    "title": "5  Loading, explore, wrangle",
    "section": "5.8 dplyr",
    "text": "5.8 dplyr\ndplyr provides a set of intuitive functions for data manipulation, such as selecting columns, filtering rows, creating new variables, and summarising data.\nA key feature of dplyr is its use of the pipe operator |&gt;\nWhat is the pipe?\nThe pipe operator allows you to write code that reads like a sequence of actions. Instead of nesting functions inside each other, you start with your data and then “pipe” it through a series of steps.\nThink of it like saying:\n\nTake this data → then do this → then do that → then do something else…\n\nThis makes your code easier to read and follow.\nExample:\n\n\nCode\ndata_names |&gt; \n  select(first_name, last_name) |&gt; \n  filter(first_name == \"X\", \n         last_name == \"Y\")\n\n\n.. reads as:\n\ntake the data_names dataset\nselect the columns first_name and last_name\nfilter rows so first_name is equal to “X” and last_name is equal to “Y”\n\nThis structure is consistent across all dplyr functions and helps build a clear and logical workflow.\nWe will get back to each functions.\nThe pipe operator can look like |&gt; and %&gt;%. The shortcut is:\n\nWindows: Shift + Ctrl + M\nmacOS: Shift + Cmd + M\n\nIf you see %&gt;%, you can change it to |&gt; by entering Shift + Crtl + P, write “pipe” and tick of “Use R’s native pipe operator, |&gt;”\nNow we will go through some key functions from mainly the dplyr package.",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Loading, explore, wrangle</span>"
    ]
  },
  {
    "objectID": "05_loading_management.html#select---choosing-columns",
    "href": "05_loading_management.html#select---choosing-columns",
    "title": "5  Loading, explore, wrangle",
    "section": "5.9 select() - Choosing columns",
    "text": "5.9 select() - Choosing columns\nSelecting columns is one of the most common tasks in data wrangling. You use select() when you want to focus on specific variables.\nWhen to use select?\n\nTo reduce clutter and focus on relevant variables\n\n\n\nTo prepare a subset of data for analysis or visualization\n\n\n\nTo reorder columns for readability\n\nExample:\nTake the diag_data and select the columns: id, adm_date, and dis_date.\n\n\nCode\ndiag_data |&gt; \n  select(id, adm_date, dis_date)\n\n\n# A tibble: 2,840,870 × 3\n   id    adm_date   dis_date  \n   &lt;fct&gt; &lt;date&gt;     &lt;date&gt;    \n 1 1     2013-08-18 2013-08-22\n 2 1     2013-11-10 2013-11-10\n 3 2     2011-02-24 2011-02-24\n 4 2     2014-04-30 2014-04-30\n 5 3     2018-07-10 2018-07-12\n 6 3     2018-07-10 2018-07-12\n 7 3     2021-04-25 2021-04-25\n 8 3     2024-07-20 2024-07-25\n 9 4     2014-09-27 2014-09-27\n10 4     2018-12-08 2018-12-08\n# ℹ 2,840,860 more rows\n\n\nHelper functions\nselect() also supports helper functions to match column names. From the tidyr package (loaded with tidyverse), these functions are handy:\n\nstarts_with(\"prefix\") - selects columns starting with “prefix”\nends_with(\"suffix\") - selects columns ending with “suffix”\ncontains(\"content\") - select columns containing “content”.\n\nSo, we could have used ends_with() as well, by typing:\n\n\nCode\ndiag_data |&gt; \n  select(id, ends_with(\"date\"))\n\n\n# A tibble: 2,840,870 × 3\n   id    adm_date   dis_date  \n   &lt;fct&gt; &lt;date&gt;     &lt;date&gt;    \n 1 1     2013-08-18 2013-08-22\n 2 1     2013-11-10 2013-11-10\n 3 2     2011-02-24 2011-02-24\n 4 2     2014-04-30 2014-04-30\n 5 3     2018-07-10 2018-07-12\n 6 3     2018-07-10 2018-07-12\n 7 3     2021-04-25 2021-04-25\n 8 3     2024-07-20 2024-07-25\n 9 4     2014-09-27 2014-09-27\n10 4     2018-12-08 2018-12-08\n# ℹ 2,840,860 more rows\n\n\nThis can be particular helpful when working with wide datasets.",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Loading, explore, wrangle</span>"
    ]
  },
  {
    "objectID": "05_loading_management.html#filter---choosing-rows",
    "href": "05_loading_management.html#filter---choosing-rows",
    "title": "5  Loading, explore, wrangle",
    "section": "5.10 filter() - Choosing rows",
    "text": "5.10 filter() - Choosing rows\nWhile select() works on columns, filter() works on rows. You use it to keep only the observations that meet certain conditions. Note that we use == when we specify a condition.\nExample:\n\n\nCode\ndiag_data |&gt; \n  filter(contact_type == 1)\n\n\n# A tibble: 799,454 × 6\n   id    contact_type adm_date   dis_date   diag_a diag_b\n   &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;  &lt;chr&gt; \n 1 1     1            2013-08-18 2013-08-22 DI12   DI10  \n 2 3     1            2018-07-10 2018-07-12 DI50   DX08  \n 3 3     1            2018-07-10 2018-07-12 DI50   DX01  \n 4 3     1            2024-07-20 2024-07-25 DX08   DI50  \n 5 5     1            2012-02-05 2012-02-12 DX06   DE78  \n 6 5     1            2012-12-23 2012-12-26 DX09   DX07  \n 7 6     1            2012-06-10 2012-06-17 DX03   DX06  \n 8 6     1            2018-01-14 2018-01-22 DI15   DI10  \n 9 6     1            2018-01-14 2018-01-22 DI15   DX04  \n10 9     1            2011-03-15 2011-03-28 DE14   DI15  \n# ℹ 799,444 more rows\n\n\nThis keeps only rows where contact_type is equal to 1 (inpatient hospital contacts).\nYou can combine multiple conditions using\n\n& for “and”\n| for “or”\n! for “not”",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Loading, explore, wrangle</span>"
    ]
  },
  {
    "objectID": "05_loading_management.html#mutate---creating-new-variables",
    "href": "05_loading_management.html#mutate---creating-new-variables",
    "title": "5  Loading, explore, wrangle",
    "section": "5.11 mutate() - Creating new variables",
    "text": "5.11 mutate() - Creating new variables\nTo add new columns to your dataset, you can use mutate(). This is useful for calculating derived variables, recoding values, or creating labels.\nExample:\n\n\nCode\ndiag_data |&gt; \n  mutate(\n    contact_type_description = \n      case_when(\n        contact_type == 1 ~ \"Inpatient\",\n        contact_type == 2 ~ \"Outpatient\"\n      )\n  )\n\n\n# A tibble: 2,840,870 × 7\n   id    contact_type adm_date   dis_date   diag_a diag_b contact_type_descrip…¹\n   &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;                 \n 1 1     1            2013-08-18 2013-08-22 DI12   DI10   Inpatient             \n 2 1     2            2013-11-10 2013-11-10 DX06   DE13   Outpatient            \n 3 2     2            2011-02-24 2011-02-24 DE13   DI14   Outpatient            \n 4 2     2            2014-04-30 2014-04-30 DI15   DE13   Outpatient            \n 5 3     1            2018-07-10 2018-07-12 DI50   DX08   Inpatient             \n 6 3     1            2018-07-10 2018-07-12 DI50   DX01   Inpatient             \n 7 3     2            2021-04-25 2021-04-25 DX03   DX04   Outpatient            \n 8 3     1            2024-07-20 2024-07-25 DX08   DI50   Inpatient             \n 9 4     2            2014-09-27 2014-09-27 DI12   DX06   Outpatient            \n10 4     2            2018-12-08 2018-12-08 DX08   DI15   Outpatient            \n# ℹ 2,840,860 more rows\n# ℹ abbreviated name: ¹​contact_type_description\n\n\nThis generates a column describing the contact_type variable. This doesn’t make much sense to do though.. But we will use mutate() sensible later on :)\nHere, we used case_when() as well. That function is used to handle multiple conditions clearly.\nIn the code above, case_when() specifies\n\nWhen contact_type is equal to 1 then assign contact_type_description the character value “Inpatient”\nWhen contact_type is equal to 2, assign contact_type_description the character value “Outpatient”.\n\ncase_when() also has a “default” option. You can use it like: if this condition is true, do this, otherwise (default) do that. So, we could also have written:\n\n\nCode\n# 01\n\ndiag_data |&gt; \n  mutate(\n    contact_type_description = \n      case_when(\n        contact_type == 1 ~ \"Inpatient\",\n        .default = \"Outpatient\"\n      )\n  )\n\n# 02\n\ndiag_data |&gt; \n  mutate(\n    contact_type_description = \n      case_when(\n        contact_type == 1 ~ \"Inpatient\",\n        TRUE ~ \"Outpatient\"\n      )\n  )\n\n\nIt is important to note, that case_when() handles the conditions in hierarchy. So, if condition 1 is true, that will overwrite any subsequent conditions. Likewise, if condition 1 is false, but condition 2 is true, that will overwrite a potential condition 3.\nMoreover, you must provide the same class of output for each condition. E.g., above we use a character output in each condition. We can’t combine e.g., character output and numeric output.\n\n\nCode\ndiag_data |&gt; \n  mutate(\n    contact_type_description = \n      case_when(\n        contact_type == 1 ~ \"Inpatient\",\n        TRUE ~ 0\n      )\n  )",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Loading, explore, wrangle</span>"
    ]
  },
  {
    "objectID": "05_loading_management.html#group_by---grouping-data",
    "href": "05_loading_management.html#group_by---grouping-data",
    "title": "5  Loading, explore, wrangle",
    "section": "5.12 group_by() - Grouping data",
    "text": "5.12 group_by() - Grouping data\nGrouping is essential when you want to perform calculations within subgroups (e.g., per patient, per hospital, per year, etc.).\nExample:\n\n\nCode\ndiag_data |&gt; \n  group_by(id)\n\n\nThis tells R to treat each id as a separate group.",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Loading, explore, wrangle</span>"
    ]
  },
  {
    "objectID": "05_loading_management.html#excercise",
    "href": "05_loading_management.html#excercise",
    "title": "5  Loading, explore, wrangle",
    "section": "5.13 Excercise",
    "text": "5.13 Excercise\nDefine inhospital admissions per patient.\n\nWhich variables do we need?\nLook only at in inpatient contacts.\nDefine the first recorded hospitalisation as number 1\nAlso count the total number of hospitalisations per patient.\n\n\n5.13.1 Choose the columns we need\n\n\nCode\ndiag_data |&gt; \n  select(id, contact_type, adm_date)\n\n\n# A tibble: 2,840,870 × 3\n   id    contact_type adm_date  \n   &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;    \n 1 1     1            2013-08-18\n 2 1     2            2013-11-10\n 3 2     2            2011-02-24\n 4 2     2            2014-04-30\n 5 3     1            2018-07-10\n 6 3     1            2018-07-10\n 7 3     2            2021-04-25\n 8 3     1            2024-07-20\n 9 4     2            2014-09-27\n10 4     2            2018-12-08\n# ℹ 2,840,860 more rows\n\n\n\n\n5.13.2 Look only at inpatient hospital contacts\n\n\nCode\ndiag_data |&gt; \n  select(id, contact_type, adm_date) |&gt; \n  filter(contact_type == 1)\n\n\n# A tibble: 799,454 × 3\n   id    contact_type adm_date  \n   &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;    \n 1 1     1            2013-08-18\n 2 3     1            2018-07-10\n 3 3     1            2018-07-10\n 4 3     1            2024-07-20\n 5 5     1            2012-02-05\n 6 5     1            2012-12-23\n 7 6     1            2012-06-10\n 8 6     1            2018-01-14\n 9 6     1            2018-01-14\n10 9     1            2011-03-15\n# ℹ 799,444 more rows\n\n\n\n\n5.13.3 Order the first recorded hospitalisation as number 1\nHere we make sure that the dataset is correctly ordered per patient.\nTo do this, we can use the group_by() and arrange() function.\n\n\nCode\ndiag_data |&gt; \n  select(id, contact_type, adm_date) |&gt; \n  filter(contact_type == 1) |&gt; \n  group_by(id) |&gt; \n  arrange(id, adm_date)\n\n\n# A tibble: 799,454 × 3\n# Groups:   id [541,052]\n   id    contact_type adm_date  \n   &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;    \n 1 1     1            2013-08-18\n 2 3     1            2018-07-10\n 3 3     1            2018-07-10\n 4 3     1            2024-07-20\n 5 5     1            2012-02-05\n 6 5     1            2012-12-23\n 7 6     1            2012-06-10\n 8 6     1            2018-01-14\n 9 6     1            2018-01-14\n10 9     1            2011-03-15\n# ℹ 799,444 more rows\n\n\n\n\n5.13.4 Keep only unique admissions\nWe can see above that some inpatient contacts occur twice.\nTo fix this, we can use the distinct() function which keeps only unique rows within the defined groups.\n\n\nCode\ndiag_data |&gt; \n  select(id, contact_type, adm_date) |&gt; \n  filter(contact_type == 1) |&gt; \n  group_by(id) |&gt; \n  arrange(id, adm_date) |&gt; \n  distinct()\n\n\n# A tibble: 696,523 × 3\n# Groups:   id [541,052]\n   id    contact_type adm_date  \n   &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;    \n 1 1     1            2013-08-18\n 2 3     1            2018-07-10\n 3 3     1            2024-07-20\n 4 5     1            2012-02-05\n 5 5     1            2012-12-23\n 6 6     1            2012-06-10\n 7 6     1            2018-01-14\n 8 9     1            2011-03-15\n 9 9     1            2021-06-22\n10 11    1            2010-08-31\n# ℹ 696,513 more rows\n\n\n\n\n5.13.5 Create an indicator of admission number\n\n\nCode\ndiag_data |&gt; \n  select(id, contact_type, adm_date) |&gt; \n  filter(contact_type == 1) |&gt; \n  group_by(id) |&gt; \n  arrange(id, adm_date) |&gt; \n  distinct() |&gt; \n  mutate(adm_nr = row_number())\n\n\n# A tibble: 696,523 × 4\n# Groups:   id [541,052]\n   id    contact_type adm_date   adm_nr\n   &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;      &lt;int&gt;\n 1 1     1            2013-08-18      1\n 2 3     1            2018-07-10      1\n 3 3     1            2024-07-20      2\n 4 5     1            2012-02-05      1\n 5 5     1            2012-12-23      2\n 6 6     1            2012-06-10      1\n 7 6     1            2018-01-14      2\n 8 9     1            2011-03-15      1\n 9 9     1            2021-06-22      2\n10 11    1            2010-08-31      1\n# ℹ 696,513 more rows\n\n\n\n\n5.13.6 Create an indicator of total number of admissions\n\n\nCode\ndiag_data |&gt; \n  select(id, contact_type, adm_date) |&gt; \n  filter(contact_type == 1) |&gt; \n  group_by(id) |&gt; \n  arrange(id, adm_date) |&gt; \n  distinct() |&gt; \n  mutate(adm_nr = row_number(),\n         adm_total = max(adm_nr)\n         )\n\n\n# A tibble: 696,523 × 5\n# Groups:   id [541,052]\n   id    contact_type adm_date   adm_nr adm_total\n   &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;      &lt;int&gt;     &lt;int&gt;\n 1 1     1            2013-08-18      1         1\n 2 3     1            2018-07-10      1         2\n 3 3     1            2024-07-20      2         2\n 4 5     1            2012-02-05      1         2\n 5 5     1            2012-12-23      2         2\n 6 6     1            2012-06-10      1         2\n 7 6     1            2018-01-14      2         2\n 8 9     1            2011-03-15      1         2\n 9 9     1            2021-06-22      2         2\n10 11    1            2010-08-31      1         2\n# ℹ 696,513 more rows",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Loading, explore, wrangle</span>"
    ]
  },
  {
    "objectID": "05_loading_management.html#joining-dataset",
    "href": "05_loading_management.html#joining-dataset",
    "title": "5  Loading, explore, wrangle",
    "section": "5.14 Joining dataset",
    "text": "5.14 Joining dataset\nTo combine datasets, use join functions:\n\nleft_join() – keeps all rows from the left dataset\nright_join() – keeps all rows from the right dataset\ninner_join() – keeps only matching rows\nfull_join() – keeps all rows from both\n\nWhen you join datasets, you need to specify\n\nThe datasets to join\nThe columns to join by\n\nThe by argument is rather essential. For instance, we can combine data from basic_data and diag_data using id. You can join by several columns if relevant.\nExample: Join basic_data and diag_data\nLet’s say you are interested in adding information birth date and death date to the diag_data\n\n\nCode\n# 01\n\nleft_join(diag_data, basic_data, by = \"id\")\n\n\n# A tibble: 2,840,870 × 9\n   id    contact_type adm_date   dis_date   diag_a diag_b birth_date death_date\n   &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;  &lt;chr&gt;  &lt;date&gt;     &lt;date&gt;    \n 1 1     1            2013-08-18 2013-08-22 DI12   DI10   1933-01-01 NA        \n 2 1     2            2013-11-10 2013-11-10 DX06   DE13   1933-01-01 NA        \n 3 2     2            2011-02-24 2011-02-24 DE13   DI14   1971-01-01 NA        \n 4 2     2            2014-04-30 2014-04-30 DI15   DE13   1971-01-01 NA        \n 5 3     1            2018-07-10 2018-07-12 DI50   DX08   1997-01-01 NA        \n 6 3     1            2018-07-10 2018-07-12 DI50   DX01   1997-01-01 NA        \n 7 3     2            2021-04-25 2021-04-25 DX03   DX04   1997-01-01 NA        \n 8 3     1            2024-07-20 2024-07-25 DX08   DI50   1997-01-01 NA        \n 9 4     2            2014-09-27 2014-09-27 DI12   DX06   1958-01-01 NA        \n10 4     2            2018-12-08 2018-12-08 DX08   DI15   1958-01-01 NA        \n# ℹ 2,840,860 more rows\n# ℹ 1 more variable: sex &lt;fct&gt;\n\n\nCode\n# 02\n\ndiag_data |&gt; left_join(basic_data, by = \"id\")\n\n\n# A tibble: 2,840,870 × 9\n   id    contact_type adm_date   dis_date   diag_a diag_b birth_date death_date\n   &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;  &lt;chr&gt;  &lt;date&gt;     &lt;date&gt;    \n 1 1     1            2013-08-18 2013-08-22 DI12   DI10   1933-01-01 NA        \n 2 1     2            2013-11-10 2013-11-10 DX06   DE13   1933-01-01 NA        \n 3 2     2            2011-02-24 2011-02-24 DE13   DI14   1971-01-01 NA        \n 4 2     2            2014-04-30 2014-04-30 DI15   DE13   1971-01-01 NA        \n 5 3     1            2018-07-10 2018-07-12 DI50   DX08   1997-01-01 NA        \n 6 3     1            2018-07-10 2018-07-12 DI50   DX01   1997-01-01 NA        \n 7 3     2            2021-04-25 2021-04-25 DX03   DX04   1997-01-01 NA        \n 8 3     1            2024-07-20 2024-07-25 DX08   DI50   1997-01-01 NA        \n 9 4     2            2014-09-27 2014-09-27 DI12   DX06   1958-01-01 NA        \n10 4     2            2018-12-08 2018-12-08 DX08   DI15   1958-01-01 NA        \n# ℹ 2,840,860 more rows\n# ℹ 1 more variable: sex &lt;fct&gt;\n\n\nYou can also specify which columns you wish to add directly in the join function.\nLet’s say we only wanted to add birth_date\n\n\nCode\ndiag_data |&gt; \n  left_join(\n    basic_data |&gt; select(id, birth_date), \n    by = \"id\")\n\n\n# A tibble: 2,840,870 × 7\n   id    contact_type adm_date   dis_date   diag_a diag_b birth_date\n   &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;  &lt;chr&gt;  &lt;date&gt;    \n 1 1     1            2013-08-18 2013-08-22 DI12   DI10   1933-01-01\n 2 1     2            2013-11-10 2013-11-10 DX06   DE13   1933-01-01\n 3 2     2            2011-02-24 2011-02-24 DE13   DI14   1971-01-01\n 4 2     2            2014-04-30 2014-04-30 DI15   DE13   1971-01-01\n 5 3     1            2018-07-10 2018-07-12 DI50   DX08   1997-01-01\n 6 3     1            2018-07-10 2018-07-12 DI50   DX01   1997-01-01\n 7 3     2            2021-04-25 2021-04-25 DX03   DX04   1997-01-01\n 8 3     1            2024-07-20 2024-07-25 DX08   DI50   1997-01-01\n 9 4     2            2014-09-27 2014-09-27 DI12   DX06   1958-01-01\n10 4     2            2018-12-08 2018-12-08 DX08   DI15   1958-01-01\n# ℹ 2,840,860 more rows",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Loading, explore, wrangle</span>"
    ]
  },
  {
    "objectID": "06_study_pop.html",
    "href": "06_study_pop.html",
    "title": "6  Study population",
    "section": "",
    "text": "6.1 basic_data and diag_data\nWe have worked a bit with the diag_data and the basic_data.\nTo get some background information, take 2 minutes to read the README file in the data_raw folder.",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Study population</span>"
    ]
  },
  {
    "objectID": "06_study_pop.html#make-a-script",
    "href": "06_study_pop.html#make-a-script",
    "title": "6  Study population",
    "section": "6.2 Make a script",
    "text": "6.2 Make a script\nFirst, make a script where we can save our code. Choose either R Markdown/Quarto or R Script.\nName it “study_pop”.\nSave it in the folder R.",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Study population</span>"
    ]
  },
  {
    "objectID": "06_study_pop.html#load-packages",
    "href": "06_study_pop.html#load-packages",
    "title": "6  Study population",
    "section": "6.3 Load packages",
    "text": "6.3 Load packages\nLoad the packages we will need under a section called “Load packages”.\nTo begin with, just load tidyverse.\n\n\nCode\nlibrary(tidyverse)",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Study population</span>"
    ]
  },
  {
    "objectID": "06_study_pop.html#load-the-datasets",
    "href": "06_study_pop.html#load-the-datasets",
    "title": "6  Study population",
    "section": "6.4 Load the datasets",
    "text": "6.4 Load the datasets\nLoad the datasets we will need under a section called “Load data”\n\n\nCode\nbasic_data &lt;- readRDS(here::here(\"data_raw/basic_data.rds\"))\n\ndiag_data &lt;- readRDS(here::here(\"data_raw/diag_data.rds\"))",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Study population</span>"
    ]
  },
  {
    "objectID": "06_study_pop.html#find-patients-with-first-time-mi",
    "href": "06_study_pop.html#find-patients-with-first-time-mi",
    "title": "6  Study population",
    "section": "6.5 Find patients with first-time MI",
    "text": "6.5 Find patients with first-time MI\nNow, we will look into different ways to restrict your dataset to patients with a given diagnosis. Here, we will be looking at MI.\n\n6.5.1 Predefined specifications:\nLet’s have a look at some predefined specifications:\n\nWhich contacts?\n\nWe will only look at MI diagnoses recorded from inpatient hospital contacts.\n\nWhich codes?\n\nIn the diag_data, MI is recorded with the International Classification of Diseases, Tenth Revision (ICD-10) DI21.\n\nWhich type of diagnosis?\n\nWe will use both primary (diag_a) and secondary diagnoses (diag_b) registrations.\n\nWhich event?\n\nWe are interested in only first-time MIs. Accordingly, we will need ensure that we order our data correctly before restricting to the first event.\n\nWhich study period?\n\nWe are interested in events throughout the entire period covered in the dataset (2010 through 2024). We will simply pretend that hospital history before this period is irrelevant (which, of course, is not a fair assumption). But in general, be aware of whether you are finding the first event in the patient’s hospital history or the first event in your study period.\n\n\nConsidering these predefined specifications and with the functions we used in the last session in mind, take a minute to reflect on how you would approach this task using dplyr manoeuvres.\n\n\n6.5.2 Steps\nMake a section called “Generate MI cohort”\n\n6.5.2.1 1. Define a new dataset\nSo far, we have actually not tried to make any changes to a dataset.\nWhen we run:\n\n\nCode\ndata |&gt; \n  ...\n\n\nNothing we do with data will be stored.\nSo how can we save our work? We use &lt;- .\n\n\nCode\ndata_updated &lt;- data |&gt; \n  ...\n\n\nHere, any changes to data will be saved in data_updated, which will appear in your Environment when you’ve run the code. Note, you do not necessarily need to give the updated data a new name.\nBack to our MI task! Let’s call our new dataset study_pop_mi.\n\n\nCode\nstudy_pop_01 &lt;- diag_data\n\n\n\n\n6.5.2.2 2. Inpatient contacts\nRestrict to inpatient contacts.\nRemember that the type of hospital contact is stored in the column contact_type and it takes the values {1 = inpatient; 2 = outpatient}. When we want to restrict to inpatient contacts, we will be choosing on rows. Therefore, we will use the filter function.\n\n\nCode\nstudy_pop_02 &lt;- diag_data |&gt; \n  filter(contact_type == 1)\n\n\nA quick way to see, if we’ve succeeded\n\n\nCode\nstudy_pop_02 |&gt; \n  distinct(contact_type)\n\n\n# A tibble: 1 × 1\n  contact_type\n  &lt;fct&gt;       \n1 1           \n\n\nHere we use the dplyr function distinct to simply return the unique values contact_type contains. Here we see that contact_type only contains the value 1. Which is what we wanted!\n\n\n6.5.2.3 3. MI contacts\nNow that we have restricted the diag_data to inpatient contacts, we can move on and only look at contacts with an MI code.\nThe diag_a and diag_b are character vectors. And now we would like to look for whether a certain pattern (i.e., a diagnosis code) is present in any rows. There are plenty of different ways to do this.\nWe will be using the grepl function from base R. Essentially, what we should know about grepl for now is that it takes the argument: (1) what pattern to search for; (2) in which column.\nRemember, you can always read more about the function by running:\n\n\nCode\n?grepl\n\n\nBecause diag_a and diag_b are character vectors, the pattern must also be written in character format.\nSo, the ICD-10 code for MI is DI21, which then would be “DI21”. We are “lucky” that MI only has one ICD-10 code. If your pattern has multiple codes, you could write, for instance, “DA01|DA02”, saying “DA01” OR “DA02”. And let’s say you were interested in the codes DI801, DI802, and DI803, you could write “DI80[1-3]”. Moreover, grepl searches for any patterns that match your input pattern. So the input “DI21” would also keep “DI214” (subcodes).\nBut let’s get back to filter our data so only MI codes are kept.\n\n\nCode\nstudy_pop_03 &lt;- study_pop_02 |&gt; \n  filter(\n    grepl(\"DI21\", diag_a) | grepl(\"DI21\", diag_b)\n  )\n\n\nThis code takes the study_pop_02 dataset, filters on rows so that only rows where diag_a or diag_b has a value that matches the pattern “DI21” is kept, and then saves the transformed data as study_pop_03.\nWhile this works, there is some simple ways we can optimise this code.\nFirst of all, we will introduce the concept of: avoid repeating yourself!\nHere, we write the pattern “DI21” twice. It is fairly simple here, but sometimes, your ICD patterns will be extremely long and complicated. And whenever you have to repeat yourself, the risk of typos increases, and your code will become extremely long.\nSo a simple way to avoid repeating yourself, is by defining your MI pattern before running the code:\n\n\nCode\nmi_code &lt;- \"DI21\"\n\nstudy_pop_03 &lt;- study_pop_02 |&gt; \n  filter(\n    grepl(mi_code, diag_a) | grepl(mi_code, diag_b)\n  )\n\n\nThis essentially does exactly the same, but you only need to define the pattern once. This also means that if you need to revise your pattern, you only need to do it in this one place!\n\n\n\n\n\n\nNote\n\n\n\n\n\nMore advanced\nWe can optimise the code further by introducing if_any:\n\n\nCode\nmi_code &lt;- \"DI21\"\n\nstudy_pop_03 &lt;- study_pop_02 |&gt; \n  filter(\n    if_any(\n      c(\n        diag_a, diag_b\n        ),\n      ~ grepl(mi_code, .x))\n         )\n\n\n\nif_any(): This function checks if any of the specified columns meet a condition. It’s useful when you want to apply the same logical test across multiple columns. Especially if we operate on more than just a few columns.\nc(diag_a, diag_b): This tells if_any() to apply the condition to both diag_a and diag_b.\n~ grepl(mi_code, .x): This is an anonymous function where .x represents each column. grepl() checks if the mi_code string is found in the column.\n\n\n\n\n\n\n6.5.2.4 4. First-time events\nNow, we would like to make sure we are only having first-time events.\nBut, how do we know if anyone has multiple events?\n\n\nCode\nstudy_pop_03 |&gt;\n  add_count(id) |&gt;\n  filter(n &gt; 1) |&gt;\n  arrange(id)\n\n\n# A tibble: 480 × 7\n   id    contact_type adm_date   dis_date   diag_a diag_b     n\n   &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;  &lt;chr&gt;  &lt;int&gt;\n 1 483   1            2017-12-10 2017-12-19 DI21   DI21       2\n 2 483   1            2022-08-18 2022-08-26 DI21   DI21       2\n 3 2469  1            2023-08-26 2023-08-31 DI21   DI21       2\n 4 2469  1            2023-10-18 2023-10-24 DI21   DI21       2\n 5 5867  1            2020-02-12 2020-03-02 DI21   DI21       2\n 6 5867  1            2023-12-24 2023-12-31 DI21   DI21       2\n 7 7695  1            2014-07-18 2014-07-25 DI21   DI21       2\n 8 7695  1            2017-08-05 2017-08-12 DI21   DI21       2\n 9 8735  1            2019-01-30 2019-02-06 DI21   DI21       2\n10 8735  1            2022-02-13 2022-02-27 DI21   DI21       2\n# ℹ 470 more rows\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nExplanation\n\nadd_count(id) adds a column n with the number of times each id appears.\n\n\n\nfilter(n &gt; 1) keeps only those with more than one MI admission.\n\n\n\narrange(id) sorts the data by id\n\n\n\n\nWe can see that at least some persons have multiple MI admissions.\nBut how many?\n\n\nCode\nstudy_pop_03 |&gt;\n  count(id) |&gt; \n  filter(n &gt; 1) |&gt; \n  count()\n\n\n# A tibble: 1 × 1\n      n\n  &lt;int&gt;\n1   240\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nExplanation\n\nFirst count(id) gives the number of rows per patient. Returns only id and n\n\n\n\nThen filter(n &gt; 1) keeps only those with multiple events.\n\n\n\nFinally, count() gives the total number of such patients.\n\n\n\n\nLet’s take our study_pop_03 and only keep first-time events.\nAgain, there’s multiple ways to do this. We will use the function slice_head() from dplyr which allow us to keep only the first n rows per group (if specified). You may also want to look into slice_tail().\n\n\nCode\nstudy_pop_04 &lt;- study_pop_03 |&gt; \n  group_by(id) |&gt; \n  arrange(adm_date) |&gt; \n  slice_head(n = 1) |&gt; \n  ungroup()\n\n\nAlternatively:\n\n\nCode\nstudy_pop_04 &lt;- study_pop_03 |&gt; \n  group_by(id) |&gt; \n  arrange(adm_date) |&gt; \n  filter(row_number() == 1L) |&gt; \n  ungroup()\n\n\n\n\nCode\nnrow(study_pop_03) - nrow(study_pop_04)\n\n\n[1] 240\n\n\nNow we can see that we have removed the 240 duplicated MI events.\nTherefore, the number of rows in study_pop_04 should be equal to the number of unique ids.\n\n\nCode\nnrow(study_pop_04) == study_pop_04 |&gt; distinct(id) |&gt; count()\n\n\n        n\n[1,] TRUE\n\n\n\n\n6.5.2.5 5. Finalise\nSince we have checked each step, we could write everything into one code:\n\n\nCode\nmi_code &lt;- \"DI21\"\n\nstudy_pop_final &lt;- \n  # step 01: define a new dataset\n  diag_data |&gt; \n  \n  # step 02: restrict to inpatient contacts\n  filter(contact_type == 1) |&gt; \n  \n  # step 03: restrict to mi contacts\n  filter(grepl(mi_code, diag_a) | grepl(mi_code, diag_b)) |&gt; \n  \n  # step 04: restrict to first event\n  group_by(id) |&gt; \n  arrange(adm_date) |&gt; \n  slice_head(n = 1) |&gt; \n  ungroup()\n\n\nWe could also choose to let the code stay as it is.\nSaving each step allows us to go back and see how many rows were removed per step.\nNow, let’s consider which columns we actually need.\nLets explore the study_pop_final.\n\n\nCode\nhead(study_pop_final)\n\n\n# A tibble: 6 × 6\n  id    contact_type adm_date   dis_date   diag_a diag_b\n  &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;  &lt;chr&gt; \n1 212   1            2014-07-18 2014-07-22 DI21   DI21  \n2 483   1            2017-12-10 2017-12-19 DI21   DI21  \n3 731   1            2023-07-27 2023-08-03 DI21   DI21  \n4 949   1            2021-11-03 2021-11-10 DI21   DI21  \n5 981   1            2020-08-05 2020-08-18 DI21   DI21  \n6 982   1            2015-05-22 2015-05-28 DI21   DI21  \n\n\nWe definitely need id.\nWe don’t really need contact_type. There’s no additional information in this after we have restricted to only inpatient contacts.\nWe most likely will need adm_date . This will often define the index date in time-to-event designs. The dis_date could be relevant if we are interested in length of hospital stay, inhospital mortality, restricting to patients surviving index admission, etc. The diag_a and diag_b is maybe not that informative to keep in the study_pop_final dataset.\nWe will make a small customisation.\nSpoiler alert: we will be using the diag_data again to identify preadmission comorbidities.\nThen it can be slightly annoying to have adm_date and diag_date appear in both datasets when joining (at least if you’re not using these dates as by arguments).\nA workaround could be to rename the adm_date in our study_pop_final dataset.\n\n\nCode\nstudy_pop_final &lt;- study_pop_final |&gt; \n  rename(\"index_date\" = adm_date)\n\nhead(study_pop_final)\n\n\n# A tibble: 6 × 6\n  id    contact_type index_date dis_date   diag_a diag_b\n  &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;  &lt;chr&gt; \n1 212   1            2014-07-18 2014-07-22 DI21   DI21  \n2 483   1            2017-12-10 2017-12-19 DI21   DI21  \n3 731   1            2023-07-27 2023-08-03 DI21   DI21  \n4 949   1            2021-11-03 2021-11-10 DI21   DI21  \n5 981   1            2020-08-05 2020-08-18 DI21   DI21  \n6 982   1            2015-05-22 2015-05-28 DI21   DI21  \n\n\nThen, we can also “transform” the dis_date into something similar without losing information - but maybe even adding information.\nInstead of keeping the dis_date, we can calculate the length of hospital stay. We can then always regenerate the dis_date from index_date and the new variable — or by going back to the diag_data.\n\n\nCode\nstudy_pop_final &lt;- study_pop_final |&gt; \n  mutate(los = as.numeric(dis_date-index_date),\n         .after = index_date)\n\nhead(study_pop_final)\n\n\n# A tibble: 6 × 7\n  id    contact_type index_date   los dis_date   diag_a diag_b\n  &lt;fct&gt; &lt;fct&gt;        &lt;date&gt;     &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;  &lt;chr&gt; \n1 212   1            2014-07-18     4 2014-07-22 DI21   DI21  \n2 483   1            2017-12-10     9 2017-12-19 DI21   DI21  \n3 731   1            2023-07-27     7 2023-08-03 DI21   DI21  \n4 949   1            2021-11-03     7 2021-11-10 DI21   DI21  \n5 981   1            2020-08-05    13 2020-08-18 DI21   DI21  \n6 982   1            2015-05-22     6 2015-05-28 DI21   DI21  \n\n\nLet’s then choose the columns we need\n\n\nCode\nstudy_pop_final &lt;- \n  study_pop_final |&gt; \n  select(id, index_date, los)\n\nhead(study_pop_final)\n\n\n# A tibble: 6 × 3\n  id    index_date   los\n  &lt;fct&gt; &lt;date&gt;     &lt;dbl&gt;\n1 212   2014-07-18     4\n2 483   2017-12-10     9\n3 731   2023-07-27     7\n4 949   2021-11-03     7\n5 981   2020-08-05    13\n6 982   2015-05-22     6\n\n\n\n\n6.5.2.6 6. Save\nSave the study_pop_final dataset in the folder data. We could call it “data_pop_mi”\n\n\nCode\nsaveRDS(study_pop_final, here::here(\"data/data_pop_mi.rds\"))\n\n\n\n\n6.5.2.7 7. Clear environment\n\n\nCode\nrm(list=ls()) # clears your working environment\n\ngc() # free unused memory\n\n\n          used (Mb) gc trigger  (Mb) max used  (Mb)\nNcells 1329854 71.1    3759476 200.8  4699345 251.0\nVcells 2801721 21.4   35169469 268.4 43746597 333.8",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Study population</span>"
    ]
  },
  {
    "objectID": "07_covariates.html",
    "href": "07_covariates.html",
    "title": "7  Covariates",
    "section": "",
    "text": "7.1 Make a script\nFirst, make a script where we can save our code. Choose either R Markdown/Quarto or R Script.\nName it “covariates”.\nSave it in the folder R.",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Covariates</span>"
    ]
  },
  {
    "objectID": "07_covariates.html#load-packages",
    "href": "07_covariates.html#load-packages",
    "title": "7  Covariates",
    "section": "7.2 Load packages",
    "text": "7.2 Load packages\nLoad the packages we will need under a section called “Load packages”.\n\n\nCode\nlibrary(tidyverse)\nlibrary(purrr)\n\n\nWe will introduce the purrr package, so we should add this as a workflow dependency\n\n\nCode\nusethis::use_package(\"purrr\")",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Covariates</span>"
    ]
  },
  {
    "objectID": "07_covariates.html#load-the-datasets",
    "href": "07_covariates.html#load-the-datasets",
    "title": "7  Covariates",
    "section": "7.3 Load the datasets",
    "text": "7.3 Load the datasets\nLoad the datasets we will need under a section called “Load data”\n\n\nCode\nbasic_data &lt;- readRDS(here::here(\"data_raw/basic_data.rds\"))\n\ndiag_data &lt;- readRDS(here::here(\"data_raw/diag_data.rds\"))\n\ndata_pop_mi &lt;- readRDS(here::here(\"data/data_pop_mi.rds\"))",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Covariates</span>"
    ]
  },
  {
    "objectID": "07_covariates.html#choose-covariates",
    "href": "07_covariates.html#choose-covariates",
    "title": "7  Covariates",
    "section": "7.4 Choose covariates",
    "text": "7.4 Choose covariates\nFirst, we must decide which covariates we would like to include.\nFrom basic_data:\n\nage\nsex\n\nFrom diag_data:\n\nHypertension\nHypercholesterolaemia\nDiabetes\nHeart failure\n\n\n7.4.1 Age and sex\nIn the basic_data, we can obtain information on age ans sex from the variables birth_date and sex.\n\n\nCode\ndata_cov_01 &lt;- data_pop_mi |&gt; \n  left_join(basic_data |&gt; select(id, birth_date, sex),\n            by = \"id\")\n\ndata_cov_01\n\n\n# A tibble: 4,000 × 5\n   id    index_date   los birth_date sex  \n   &lt;fct&gt; &lt;date&gt;     &lt;dbl&gt; &lt;date&gt;     &lt;fct&gt;\n 1 212   2014-07-18     4 1941-01-01 1    \n 2 483   2017-12-10     9 1918-01-01 2    \n 3 731   2023-07-27     7 1931-01-01 2    \n 4 949   2021-11-03     7 1954-01-01 1    \n 5 981   2020-08-05    13 1945-01-01 2    \n 6 982   2015-05-22     6 1945-01-01 2    \n 7 1123  2015-07-25     6 1955-01-01 1    \n 8 2166  2016-09-30     7 1962-01-01 1    \n 9 2469  2023-08-26     5 1920-01-02 2    \n10 2870  2010-09-03    14 1939-01-01 1    \n# ℹ 3,990 more rows\n\n\nNow, we can calculate age at admission\n\n\nCode\ndata_cov_02 &lt;- data_cov_01 |&gt; \n  mutate(\n    age = round(as.numeric(index_date - birth_date)/365.25,0)\n  )\n\ndata_cov_02\n\n\n# A tibble: 4,000 × 6\n   id    index_date   los birth_date sex     age\n   &lt;fct&gt; &lt;date&gt;     &lt;dbl&gt; &lt;date&gt;     &lt;fct&gt; &lt;dbl&gt;\n 1 212   2014-07-18     4 1941-01-01 1        74\n 2 483   2017-12-10     9 1918-01-01 2       100\n 3 731   2023-07-27     7 1931-01-01 2        93\n 4 949   2021-11-03     7 1954-01-01 1        68\n 5 981   2020-08-05    13 1945-01-01 2        76\n 6 982   2015-05-22     6 1945-01-01 2        70\n 7 1123  2015-07-25     6 1955-01-01 1        61\n 8 2166  2016-09-30     7 1962-01-01 1        55\n 9 2469  2023-08-26     5 1920-01-02 2       104\n10 2870  2010-09-03    14 1939-01-01 1        72\n# ℹ 3,990 more rows\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nExplanation\n\nround(): specifies the number of digits\nas.numeric(): specifies that the difference between index_date and birth_date should be a numeric value, which allows us to divide by 365.25 to obtain age in years.\n\n\n\n\n\n7.4.1.1 Normal distributed\nLet’s have a look at whether the age distribution of our MI patients follow a normal distribution. And let’s see if it differs between sex.\nFor this, we will be using ggplot2.\n\n7.4.1.1.1 What is ggplot2?\nggplot2 is a system for creating graphics based on the Grammar of Graphics — a structured way of thinking about and building plots. Instead of using one function to create a plot all at once, you build your plot step by step by adding layers.\nThis makes your code more readable, flexible, and easier to modify.\nA ggplot2 plot always starts with the ggplot() function. Then you add layers using the + operator.\nHere’s the basic structure:\n\n\nCode\ndata |&gt; \n  ggplot(aes(x = x_variable, y = y_variable)) +\n  geom_function()\n\n\nLet’s break that down:\n\ndata: Specify which data we will be using\nggplot(): This sets up the plot.\naes(): Short for aesthetics — this is where you define what goes on the x- and y-axes (and optionally color, size, shape, etc.).\ngeom_*(): These are the layers that define how the data should be visualised — for example:\n\ngeom_point() for scatter plots\ngeom_bar() for bar charts\ngeom_line() for line plots\ngeom_histogram() for histograms\n\n\nLet’s see if the age distribution is normally distributed and stratify by sex.\n\n\n7.4.1.1.2 QQ plot\n\n\nCode\ndata_cov_02 |&gt; \n  mutate(sex = factor(sex, levels = c(1,2), labels = c(\"Male\", \"Female\"))) |&gt; \n  ggplot(aes(sample = age, group = sex, color = sex, fill = sex)) + \n  geom_qq() + \n  geom_qq_line() + \n  facet_wrap(~sex) + \n  ggsci::scale_fill_nejm() + \n  ggsci::scale_color_nejm() + \n  theme_bw()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nExplanation\n\nmutate(sex = factor(...))\nConverts the numeric sex variable (1/2) into a labeled factor with levels “Male” and “Female” — making the plot more interpretable.\nggplot(aes(...))\nInitialises a ggplot object using age as the variable to be plotted in a Q-Q plot.\n\nsample = age: Specifies the variable to be compared against a theoretical normal distribution.\ngroup = sex: Ensures separate Q-Q plots are generated for each sex group.\ncolor and fill: Assign colors based on sex.\n\ngeom_qq()\nAdds a Q-Q plot layer — this visualizes how the distribution of age compares to a normal distribution.\ngeom_qq_line()\nAdds a reference line to the Q-Q plot — if the data follows a normal distribution, points should lie close to this line.\nfacet_wrap(~sex)\nCreates separate plots for “Male” and “Female” — allowing for side-by-side comparison of age distributions.\nggsci::scale_fill_nejm() and ggsci::scale_color_nejm()\nApplies a color palette inspired by the New England Journal of Medicine.\nNote, here we call the functions directly from the ggsci package. We could also load the package under “Load packages”. That will largely depend on how frequently we will use it, and whether it conflicts with other packages. But, we should add it as a workflow-dependency package in our DESCRIPTION file.\n\n\nCode\nusethis::use_package(\"ggsci\")\n\n\ntheme_bw()\nApplies a minimal black-and-white theme — removes background shading and grid clutter for a cleaner appearance. There are tons of themes you can use. Moreover, using the theme() function, you can customise your layout intensively.\n\n\n\n\n\n\n7.4.1.1.3 Histogram\n\n\nCode\ndata_cov_02 |&gt; \n  mutate(sex = factor(sex, levels = c(1, 2), labels = c(\"Male\", \"Female\"))) |&gt; \n  ggplot(aes(x = age, group = sex, color = sex, fill = sex)) + \n  geom_histogram(aes(y = ..density..), alpha = .25) +\n  stat_function(fun=dnorm, args = list(mean = mean(data_cov_02$age), sd = sd(data_cov_02$age)), linewidth = .75) + \n  facet_wrap(~ sex) +\n  ggsci::scale_fill_nejm() + \n  ggsci::scale_color_nejm() +\n  theme_bw()\n\n\nWarning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(density)` instead.\n\n\n`stat_bin()` using `bins = 30`. Pick better value `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nExplanation\n\nmutate(sex = factor(...))\nConverts the numeric sex variable (1 = Male, 2 = Female) into a labeled factor for clearer plotting and legend labels.\nggplot(aes(...))\nInitializes the plot using age as the x-axis variable.\n\ngroup = sex: Ensures separate density curves per sex.\ncolor and fill: Assign colors based on sex for visual distinction.\n\ngeom_histogram(aes(y = ..density..), alpha = .25)\nPlots a histogram of the age variable, scaled to show density rather than raw counts.\n\nalpha = .25: Makes the bars semi-transparent so overlapping areas are visible.\n\nstat_function(fun = dnorm, ...)\nAdds a normal distribution curve over the histogram using the overall mean and standard deviation of age.\n\nThis helps visually compare the actual age distribution to a theoretical normal distribution.\n\nfacet_wrap(~ sex)\nCreates separate panels for “Male” and “Female” — allowing side-by-side comparison of age distributions.\n\nggsci::scale_fill_nejm() and ggsci::scale_color_nejm()\nApplies a color palette inspired by the New England Journal of Medicine.\nNote, here we call the functions directly from the ggsci package. We could also load the package under “Load packages”. That will largely depend on how frequently we will use it, and whether it conflicts with other packages. But, we should add it as a workflow-dependency package in our DESCRIPTION file.\n\ntheme_bw()\nApplies a minimal black-and-white theme — removes background shading and grid clutter for a cleaner appearance. There are tons of themes you can use. Moreover, using the theme() function, you can customise your layout intensively.\n\n\n\n\n\n\n\n\n7.4.2 Comorbidities\nThe diag_data contains the following diseases and codes.\n\nComorbidities and ICD-10 codes\n\n\nComorbidity\nICD-10 code\n\n\n\n\nMyocardial infarction\nDI21\n\n\nHypertension\nDI10, DI11, DI12, DI13, DI14, DI15\n\n\nHypercholesterolaemia\nDE78\n\n\nDiabetes\nDE10, DE11, DE12, DE13, DE14\n\n\nHeart failure\nDI50\n\n\nRandom\nDX01, DX02, DX03, DX04, DX05, DX06, DX07, DX08, DX09\n\n\n\nThere are several different ways to identify comorbidities. Here, we will go over a couple.\nWe set some assumptions.\n\nWe do not include information on diagnoses recorded during index admission\nWe include diagnoses recorded within 10 years from the index date (i.e., 10 years lookback)\nWe include diagnoses from both inpatient and outpatient hospital contacts\nWe include diagnoses recorded as either a primary and a secondary diagnosis.\nWe apply the same assumptions for all comorbidities.\n\n\n\n7.4.3 Baseline, identify, add\nOne approach is to\n\n7.4.3.1 Step 1. Define a baseline study pop set\n\n\nCode\ndata_baseline_mi &lt;- data_pop_mi |&gt; \n  select(id, index_date)\n\n\n\n\n7.4.3.2 Step 2. Define a baseline comorbidity set, add diag_data, keep only diagnoses recorded before index date and after lookback period\n\n\nCode\nlookback_years &lt;- 10\n\nlookback &lt;- lookback_years*-1\n\ndata_cov_diag &lt;- data_pop_mi |&gt; \n  select(id, index_date) |&gt; \n  left_join(diag_data, by = \"id\") |&gt; \n  mutate(\n    diff = as.numeric(adm_date - index_date) # can also be switched, then just adjusted definition of lookback\n  ) |&gt; \n  filter(\n    diff &lt; 0,\n    diff &gt; 365.25*lookback\n  ) |&gt; \n  select(-diff)\n\ndata_cov_diag\n\n\n# A tibble: 7,917 × 7\n   id    index_date contact_type adm_date   dis_date   diag_a diag_b\n   &lt;fct&gt; &lt;date&gt;     &lt;fct&gt;        &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;  &lt;chr&gt; \n 1 949   2021-11-03 2            2015-07-02 2015-07-02 DE78   DE78  \n 2 949   2021-11-03 1            2017-06-07 2017-06-08 DI50   DI50  \n 3 949   2021-11-03 2            2020-06-26 2020-06-26 DE78   DE78  \n 4 949   2021-11-03 1            2021-01-07 2021-01-11 DI50   DI50  \n 5 949   2021-11-03 1            2021-03-14 2021-03-20 DI50   DI50  \n 6 949   2021-11-03 2            2021-06-25 2021-06-25 DE78   DE78  \n 7 982   2015-05-22 2            2010-07-27 2010-07-27 DE78   DE78  \n 8 982   2015-05-22 2            2011-01-18 2011-01-18 DE78   DE78  \n 9 982   2015-05-22 2            2012-12-26 2012-12-26 DE78   DE78  \n10 1123  2015-07-25 2            2011-01-13 2011-01-13 DE78   DE78  \n# ℹ 7,907 more rows\n\n\n\n\n7.4.3.3 Step 3. Identify whether patients with a given covariate\nLet’s begin with hypertension.\n\n\nCode\nhypertension_code &lt;- c(\"DI1[0-5]\")\n\ncov_hypertension &lt;- data_cov_diag |&gt; \n  mutate(\n    hypertension = \n      case_when(\n        grepl(hypertension_code, diag_a) | grepl(hypertension_code,diag_b) ~ 1,\n        .default = 0\n      )) |&gt; \n  filter(hypertension == 1) |&gt; \n  select(id, hypertension) |&gt; \n  distinct()\n\n\n\n\n7.4.3.4 Step 4. Add the covariate to the baseline\n\n\nCode\ndata_baseline_mi &lt;- \n  data_baseline_mi |&gt; \n  left_join(cov_hypertension, by = \"id\") |&gt; \n  mutate(hypertension = replace_na(hypertension, 0))\n\n\n\n\n7.4.3.5 Step 5. Repeat\nLets repeat for hypercholesterolaemia\n\n\nCode\nhyperchol_code &lt;- \"DE78\"\n\ncov_hyperchol &lt;- data_cov_diag |&gt; \n  mutate(\n    hyperchol = \n      case_when(\n        grepl(hyperchol_code, diag_a) | grepl(hyperchol_code,diag_b) ~ 1,\n        .default = 0\n      )) |&gt; \n  filter(hyperchol == 1) |&gt; \n  select(id, hyperchol) |&gt; \n  distinct()\n\ndata_baseline_mi &lt;- \n  data_baseline_mi |&gt; \n  left_join(cov_hyperchol, by = \"id\") |&gt; \n  mutate(hyperchol = replace_na(hyperchol, 0))\n\ndata_baseline_mi\n\n\n# A tibble: 4,000 × 4\n   id    index_date hypertension hyperchol\n   &lt;fct&gt; &lt;date&gt;            &lt;dbl&gt;     &lt;dbl&gt;\n 1 212   2014-07-18            0         0\n 2 483   2017-12-10            0         0\n 3 731   2023-07-27            0         0\n 4 949   2021-11-03            0         1\n 5 981   2020-08-05            0         0\n 6 982   2015-05-22            0         1\n 7 1123  2015-07-25            0         1\n 8 2166  2016-09-30            0         1\n 9 2469  2023-08-26            0         0\n10 2870  2010-09-03            0         0\n# ℹ 3,990 more rows\n\n\n\n\n7.4.3.6 Step 6. Keep on repeating..\nWhile this works, it gets slightly redundant — and we are repeating ourselves a lot!\n\n\n\n7.4.4 Function based\nAs the number of comorbidities grows, repeating the same code for each one becomes inefficient and hard to maintain. A more efficient and slightly advanced approach is to:\n\nCreate a baseline dataset with one row per patient\nDefine a lookup table with comorbidity names and ICD-10 patterns\nWrite a function that identifies each comorbidity\nUse pmap() to apply the function across all comorbidities\nCombine the results into a single dataset\n\nThis method is scalable, readable, and easy to adapt to new comorbidities.\n\n7.4.4.1 Step 1. Make a baseline dataset\n\n\nCode\ndata_baseline_mi &lt;- data_pop_mi |&gt; \n  select(id, index_date)\n\n\n\n\n7.4.4.2 Step 2. Make a list\nThen we list the diseases of interest and their ICD-10 codes in a vector. This can also be an Excel-file you prepare and load into R.\n\n\nCode\ncomorbidity_definitions &lt;- \n  tibble::tibble(\n  name = c(\"hypertension\", \"hypercholesterolaemia\", \"diabetes\", \"heart_failure\"),\n  pattern = c(\"DI1[0-5]\", \"DE78\", \"DE1[0-4]\", \"DI50\")\n)\n\ncomorbidity_definitions\n\n\n# A tibble: 4 × 2\n  name                  pattern \n  &lt;chr&gt;                 &lt;chr&gt;   \n1 hypertension          DI1[0-5]\n2 hypercholesterolaemia DE78    \n3 diabetes              DE1[0-4]\n4 heart_failure         DI50    \n\n\n\n\n7.4.4.3 Step 3. Make a function\nThis function takes a comorbidity name and pattern, filters data_cov_diag, and returns a dataset with a binary indicator:\n\n\nCode\nidentify_comorbidity &lt;- function(name, pattern, data) {\n  \n  print(name)\n  \n  data |&gt;\n    group_by(id, index_date) |&gt;\n    summarise(\n      !!name := as.integer(any(grepl(pattern, diag_a) | grepl(pattern, diag_b))),\n      .groups = \"drop\"\n    )\n}\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nExplanation\n\nTakes a comorbidity name and pattern.\nUses grepl() to search for the pattern in both diag_a and diag_b.\nUses any() within summarise() to assign a binary indicator (1 if the pattern is found, 0 otherwise).\nGroups by id and index_date to ensure one row per patient.\n\n\n\n\n\n\n7.4.4.4 Step 4. Apply the function\n\n\nCode\ncomorbidity_data &lt;- comorbidity_definitions |&gt;\n  pmap(function(name, pattern) identify_comorbidity(name, pattern, data_cov_diag)) |&gt;\n  reduce(full_join, by = c(\"id\", \"index_date\"))\n\n\n[1] \"hypertension\"\n[1] \"hypercholesterolaemia\"\n[1] \"diabetes\"\n[1] \"heart_failure\"\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nExplanation\n\npmap() Applies the function across all rows in the lookup table, passing name and pattern to the function.\nreduce(full_join, by = c(\"id\", \"index_date\")) Combines all comorbidity indicators into one dataset, keeping one row per patient.\n\n\n\n\n\n\n7.4.4.5 Step 5. Combine with age and sex\n\n\nCode\ndata_covariates_mi &lt;- \n  data_cov_02 |&gt; \n  left_join(comorbidity_data, by = c(\"id\", \"index_date\")) \n\ncovariates &lt;- paste0(comorbidity_definitions$name)\n\ndata_covariates_mi &lt;- data_covariates_mi |&gt; \n  mutate(\n    across(c(\n           covariates\n           ),\n           ~ replace_na(.x, 0)\n  )\n  )\n\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `across(c(covariates), ~replace_na(.x, 0))`.\nCaused by warning:\n! Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %&gt;% select(covariates)\n\n  # Now:\n  data %&gt;% select(all_of(covariates))\n\nSee &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;.\n\n\nCode\ndata_covariates_mi\n\n\n# A tibble: 4,000 × 10\n   id    index_date   los birth_date sex     age hypertension\n   &lt;fct&gt; &lt;date&gt;     &lt;dbl&gt; &lt;date&gt;     &lt;fct&gt; &lt;dbl&gt;        &lt;int&gt;\n 1 212   2014-07-18     4 1941-01-01 1        74            0\n 2 483   2017-12-10     9 1918-01-01 2       100            0\n 3 731   2023-07-27     7 1931-01-01 2        93            0\n 4 949   2021-11-03     7 1954-01-01 1        68            0\n 5 981   2020-08-05    13 1945-01-01 2        76            0\n 6 982   2015-05-22     6 1945-01-01 2        70            0\n 7 1123  2015-07-25     6 1955-01-01 1        61            0\n 8 2166  2016-09-30     7 1962-01-01 1        55            0\n 9 2469  2023-08-26     5 1920-01-02 2       104            0\n10 2870  2010-09-03    14 1939-01-01 1        72            0\n# ℹ 3,990 more rows\n# ℹ 3 more variables: hypercholesterolaemia &lt;int&gt;, diabetes &lt;int&gt;,\n#   heart_failure &lt;int&gt;",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Covariates</span>"
    ]
  },
  {
    "objectID": "07_covariates.html#save",
    "href": "07_covariates.html#save",
    "title": "7  Covariates",
    "section": "7.5 Save",
    "text": "7.5 Save\nSave the data_covariates_mi dataset in the folder data.\n\n\nCode\nsaveRDS(data_covariates_mi, here::here(\"data/data_covariates_mi.rds\"))",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Covariates</span>"
    ]
  },
  {
    "objectID": "07_covariates.html#clear-environment",
    "href": "07_covariates.html#clear-environment",
    "title": "7  Covariates",
    "section": "7.6 Clear environment",
    "text": "7.6 Clear environment\n\n\nCode\nrm(list=ls()) # clears your working environment\n\ngc() # free unused memory\n\n\n          used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells 2627957 140.4    4706242 251.4  4706242 251.4\nVcells 6387072  48.8   40849429 311.7 43859595 334.7",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Covariates</span>"
    ]
  },
  {
    "objectID": "08_table1.html",
    "href": "08_table1.html",
    "title": "8  Table 1",
    "section": "",
    "text": "8.1 Make a script\nFirst, make a script where we can save our code. Choose either R Markdown/Quarto or R Script.\nName it “table1”.\nSave it in the folder R.",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Table 1</span>"
    ]
  },
  {
    "objectID": "08_table1.html#load-packages",
    "href": "08_table1.html#load-packages",
    "title": "8  Table 1",
    "section": "8.2 Load packages",
    "text": "8.2 Load packages\nLoad the packages we will need under a section called “Load packages”.\n\n\nCode\nlibrary(tidyverse)\nlibrary(gtsummary)\nlibrary(writexl)\n\n\nWe will introduce the gtsummary package, so we should add this as a workflow dependency. Similar with writexl.\n\n\nCode\nusethis::use_package(\"gtsummary\")\nusethis::use_package(\"writexl\")",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Table 1</span>"
    ]
  },
  {
    "objectID": "08_table1.html#load-data",
    "href": "08_table1.html#load-data",
    "title": "8  Table 1",
    "section": "8.3 Load data",
    "text": "8.3 Load data\n\n\nCode\ndata_covariates_mi &lt;- readRDS(here::here(\"data/data_covariates_mi.rds\"))\n\n\nLet’s recap the variables, we have\n\n\nCode\nglimpse(data_covariates_mi)\n\n\nRows: 4,000\nColumns: 10\n$ id                    &lt;fct&gt; 212, 483, 731, 949, 981, 982, 1123, 2166, 2469, …\n$ index_date            &lt;date&gt; 2014-07-18, 2017-12-10, 2023-07-27, 2021-11-03,…\n$ los                   &lt;dbl&gt; 4, 9, 7, 7, 13, 6, 6, 7, 5, 14, 4, 8, 9, 2, 7, 1…\n$ birth_date            &lt;date&gt; 1941-01-01, 1918-01-01, 1931-01-01, 1954-01-01,…\n$ sex                   &lt;fct&gt; 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, …\n$ age                   &lt;dbl&gt; 74, 100, 93, 68, 76, 70, 61, 55, 104, 72, 36, 61…\n$ hypertension          &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, …\n$ hypercholesterolaemia &lt;int&gt; 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, …\n$ diabetes              &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, …\n$ heart_failure         &lt;int&gt; 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Table 1</span>"
    ]
  },
  {
    "objectID": "08_table1.html#make-the-table-1",
    "href": "08_table1.html#make-the-table-1",
    "title": "8  Table 1",
    "section": "8.4 Make the Table 1",
    "text": "8.4 Make the Table 1\n\n\nCode\ntbl_summary(\n  data_covariates_mi,\n  include = c(age, sex, los, hypertension, hypercholesterolaemia, diabetes, heart_failure),\n  by = sex,\n  missing = \"no\"\n) |&gt;\n  bold_labels() |&gt;\n  modify_header(label = \"**Variable**\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVariable\n1\nN = 2,5001\n2\nN = 1,5001\n\n\n\n\nage\n65 (55, 75)\n73 (62, 84)\n\n\nlos\n7.0 (6.0, 9.0)\n7.0 (5.0, 9.0)\n\n\nhypertension\n657 (26%)\n500 (33%)\n\n\nhypercholesterolaemia\n737 (29%)\n469 (31%)\n\n\ndiabetes\n371 (15%)\n201 (13%)\n\n\nheart_failure\n137 (5.5%)\n91 (6.1%)\n\n\n\n1 Median (Q1, Q3); n (%)\n\n\n\n\n\n\n\n\n\n\n8.4.1 Adjust labels\n\n\nCode\ntbl_summary(\n  data_covariates_mi,\n  include = c(age, sex, los, hypertension, hypercholesterolaemia, diabetes, heart_failure),\n  by = sex,\n  missing = \"no\",\n  label = list(\n    age ~ \"Median age, in years (Q1;Q3)\",\n    los ~ \"Median hospital stay, in days (Q1;Q3)\",\n    hypertension ~ \"Hypertension\",\n    hypercholesterolaemia ~ \"Hypercholesterolaemia\",\n    diabetes ~ \"Diabetes\",\n    heart_failure ~ \"Heart failure\"\n  )\n) |&gt;\n  bold_labels() |&gt;\n  modify_header(label = \"**Variable**\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVariable\n1\nN = 2,5001\n2\nN = 1,5001\n\n\n\n\nMedian age, in years (Q1;Q3)\n65 (55, 75)\n73 (62, 84)\n\n\nMedian hospital stay, in days (Q1;Q3)\n7.0 (6.0, 9.0)\n7.0 (5.0, 9.0)\n\n\nHypertension\n657 (26%)\n500 (33%)\n\n\nHypercholesterolaemia\n737 (29%)\n469 (31%)\n\n\nDiabetes\n371 (15%)\n201 (13%)\n\n\nHeart failure\n137 (5.5%)\n91 (6.1%)\n\n\n\n1 Median (Q1, Q3); n (%)\n\n\n\n\n\n\n\n\n\nTo adjust labels for sex, we could do something like:\n\n\nCode\ndata_covariates_mi |&gt;\n  mutate(sex = factor(sex, levels = c(1, 2), labels = c(\"Male\", \"Female\"))) |&gt;\n  tbl_summary(\n    include = c(age, sex, los, hypertension, hypercholesterolaemia, diabetes, heart_failure),\n    by = sex,\n    missing = \"no\",\n    label = list(\n      age ~ \"Median age, in years (Q1;Q3)\",\n      los ~ \"Median hospital stay, in days (Q1;Q3)\",\n      hypertension ~ \"Hypertension\",\n      hypercholesterolaemia ~ \"Hypercholesterolaemia\",\n      diabetes ~ \"Diabetes\",\n      heart_failure ~ \"Heart failure\"\n    )\n  ) |&gt;\n  bold_labels() |&gt;\n  modify_header(label = \"**Variable**\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVariable\nMale\nN = 2,5001\nFemale\nN = 1,5001\n\n\n\n\nMedian age, in years (Q1;Q3)\n65 (55, 75)\n73 (62, 84)\n\n\nMedian hospital stay, in days (Q1;Q3)\n7.0 (6.0, 9.0)\n7.0 (5.0, 9.0)\n\n\nHypertension\n657 (26%)\n500 (33%)\n\n\nHypercholesterolaemia\n737 (29%)\n469 (31%)\n\n\nDiabetes\n371 (15%)\n201 (13%)\n\n\nHeart failure\n137 (5.5%)\n91 (6.1%)\n\n\n\n1 Median (Q1, Q3); n (%)\n\n\n\n\n\n\n\n\n\nIf your exposure is not totally self-explanatory, we can add a header\n\n\nCode\ndata_covariates_mi |&gt;\n  mutate(sex = factor(sex, levels = c(1, 2), labels = c(\"Male\", \"Female\"))) |&gt;\n  tbl_summary(\n    include = c(age, sex, los, hypertension, hypercholesterolaemia, diabetes, heart_failure),\n    by = sex,\n    missing = \"no\",\n    label = list(\n      age ~ \"Median age, in years (Q1;Q3)\",\n      los ~ \"Median hospital stay, in days (Q1;Q3)\",\n      hypertension ~ \"Hypertension\",\n      hypercholesterolaemia ~ \"Hypercholesterolaemia\",\n      diabetes ~ \"Diabetes\",\n      heart_failure ~ \"Heart failure\"\n    ),\n    statistic = list(all_continuous() ~ \"{median} ({p25};{p75})\") # customise the Q1;Q3\n  ) |&gt;\n  bold_labels() |&gt;\n  modify_header(label = \"**Variable**\") |&gt; \n  modify_spanning_header(c(\"stat_1\", \"stat_2\") ~ \"**Sex**\") |&gt; \n  add_overall(last = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVariable\n\nSex\n\nOverall\nN = 4,0001\n\n\nMale\nN = 2,5001\nFemale\nN = 1,5001\n\n\n\n\nMedian age, in years (Q1;Q3)\n65 (55;75)\n73 (62;84)\n68 (57;79)\n\n\nMedian hospital stay, in days (Q1;Q3)\n7.0 (6.0;9.0)\n7.0 (5.0;9.0)\n7.0 (5.0;9.0)\n\n\nHypertension\n657 (26%)\n500 (33%)\n1,157 (29%)\n\n\nHypercholesterolaemia\n737 (29%)\n469 (31%)\n1,206 (30%)\n\n\nDiabetes\n371 (15%)\n201 (13%)\n572 (14%)\n\n\nHeart failure\n137 (5.5%)\n91 (6.1%)\n228 (5.7%)\n\n\n\n1 Median (Q1;Q3); n (%)\n\n\n\n\n\n\n\n\n\n\n\n8.4.2 Age groups\nHow does it handle categorical variables?\nLets try to create age groups\n\n\nCode\ndata_covariates_mi &lt;- data_covariates_mi |&gt; \n  mutate(\n    agegroup = \n      case_when(\n        age &lt; 50 ~ \"&lt;50\",\n        age %in% c(50:80) ~ \"50-80\",\n        age &gt; 80 ~ \"&gt;80\"\n      ),\n    .before = hypertension\n  ) |&gt; \n  mutate(\n    agegroup = factor(agegroup, levels = c(\"&lt;50\", \"50-80\", \"&gt;80\"))\n  )\n\n\n\n\n8.4.3 Add overall\n\n\nCode\ndata_covariates_mi |&gt;\n  mutate(sex = factor(sex, levels = c(1, 2), labels = c(\"Male\", \"Female\"))) |&gt;\n  tbl_summary(\n    include = c(age,agegroup, sex, los, hypertension, hypercholesterolaemia, diabetes, heart_failure),\n    by = sex,\n    missing = \"no\",\n    label = list(\n      age ~ \"Median age, in years (Q1;Q3)\",\n      agegroup ~ \"Age group\",\n      los ~ \"Median hospital stay, in days (Q1;Q3)\",\n      hypertension ~ \"Hypertension\",\n      hypercholesterolaemia ~ \"Hypercholesterolaemia\",\n      diabetes ~ \"Diabetes\",\n      heart_failure ~ \"Heart failure\"\n    ),\n    statistic = list(all_continuous() ~ \"{median} ({p25};{p75})\") # customise the Q1;Q3\n  ) |&gt;\n  bold_labels() |&gt;\n  modify_header(label = \"**Variable**\") |&gt; \n  modify_spanning_header(c(\"stat_1\", \"stat_2\") ~ \"**Sex**\") |&gt; \n  add_overall(last = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVariable\n\nSex\n\nOverall\nN = 4,0001\n\n\nMale\nN = 2,5001\nFemale\nN = 1,5001\n\n\n\n\nMedian age, in years (Q1;Q3)\n65 (55;75)\n73 (62;84)\n68 (57;79)\n\n\nAge group\n\n\n\n\n\n\n\n\n    &lt;50\n398 (16%)\n94 (6.3%)\n492 (12%)\n\n\n    50-80\n1,714 (69%)\n942 (63%)\n2,656 (66%)\n\n\n    &gt;80\n388 (16%)\n464 (31%)\n852 (21%)\n\n\nMedian hospital stay, in days (Q1;Q3)\n7.0 (6.0;9.0)\n7.0 (5.0;9.0)\n7.0 (5.0;9.0)\n\n\nHypertension\n657 (26%)\n500 (33%)\n1,157 (29%)\n\n\nHypercholesterolaemia\n737 (29%)\n469 (31%)\n1,206 (30%)\n\n\nDiabetes\n371 (15%)\n201 (13%)\n572 (14%)\n\n\nHeart failure\n137 (5.5%)\n91 (6.1%)\n228 (5.7%)\n\n\n\n1 Median (Q1;Q3); n (%)",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Table 1</span>"
    ]
  },
  {
    "objectID": "08_table1.html#save",
    "href": "08_table1.html#save",
    "title": "8  Table 1",
    "section": "8.5 Save",
    "text": "8.5 Save\nWhen we are happy with the ouput, we can save the Table 1. You can save as an Excel-file, making it ready for your manuscript (if you write that in e.g., Microsoft Word).\n\n\nCode\ntable1 &lt;- \n  data_covariates_mi |&gt;\n  mutate(sex = factor(sex, levels = c(1, 2), labels = c(\"Male\", \"Female\"))) |&gt;\n  tbl_summary(\n    include = c(age,agegroup, sex, los, hypertension, hypercholesterolaemia, diabetes, heart_failure),\n    by = sex,\n    missing = \"no\",\n    label = list(\n      age ~ \"Median age, in years (Q1;Q3)\",\n      agegroup ~ \"Age group\",\n      los ~ \"Median hospital stay, in days (Q1;Q3)\",\n      hypertension ~ \"Hypertension\",\n      hypercholesterolaemia ~ \"Hypercholesterolaemia\",\n      diabetes ~ \"Diabetes\",\n      heart_failure ~ \"Heart failure\"\n    ),\n    statistic = list(all_continuous() ~ \"{median} ({p25};{p75})\") # customise the Q1;Q3\n  ) |&gt;\n  bold_labels() |&gt;\n  modify_header(label = \"**Variable**\") |&gt; \n  modify_spanning_header(c(\"stat_1\", \"stat_2\") ~ \"**Sex**\") |&gt; \n  add_overall(last = TRUE)\n\n\nWhere to save it? That’s essentially up to you. You could make a new folder and name it “results” or something similar. Using this approach, you can save it an .html file for later exploration. You can also save as .xlsx, but may require some additional cleaning.\n\n\nCode\ntable1_gt &lt;- as_gt(table1)\ngt::gtsave(table1_gt, filename = here::here(\"results/table1.html\"))",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Table 1</span>"
    ]
  },
  {
    "objectID": "09_survival.html",
    "href": "09_survival.html",
    "title": "9  Time-to-event setup",
    "section": "",
    "text": "9.1 Make a script\nFirst, make a script where we can save our code. Choose either R Markdown/Quarto or R Script.\nName it “mortality”.\nSave it in the folder R.",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Time-to-event setup</span>"
    ]
  },
  {
    "objectID": "09_survival.html#load-packages",
    "href": "09_survival.html#load-packages",
    "title": "9  Time-to-event setup",
    "section": "9.2 Load packages",
    "text": "9.2 Load packages\nLoad the packages we will need under a section called “Load packages”.\n\n\nCode\nlibrary(tidyverse)\nlibrary(survival)\nlibrary(ggsurvfit)\nlibrary(glue)\nlibrary(writexl)\n\n\nAdd new packages to the DESCRIPTION file.\n\n\nCode\nusethis::use_package(\"survival\")\nusethis::use_package(\"glue\")\nusethis::use_package(\"writexl\")",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Time-to-event setup</span>"
    ]
  },
  {
    "objectID": "09_survival.html#load-data",
    "href": "09_survival.html#load-data",
    "title": "9  Time-to-event setup",
    "section": "9.3 Load data",
    "text": "9.3 Load data\n\n\nCode\ndata_pop_mi &lt;- readRDS(here::here(\"data/data_pop_mi.rds\"))\n\nbasic_data &lt;- readRDS(here::here(\"data_raw/basic_data.rds\"))",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Time-to-event setup</span>"
    ]
  },
  {
    "objectID": "09_survival.html#time-to-event-setup",
    "href": "09_survival.html#time-to-event-setup",
    "title": "9  Time-to-event setup",
    "section": "9.4 Time-to-event setup",
    "text": "9.4 Time-to-event setup\nNow, we will setup our dataset for a time-to-event analysis. We will follow patients from index_date until death, 1 year of follow-up, or December 31, 2024, whichever occurred first. We here just assume no emigration.\n\n9.4.1 Step 01: Add death date\n\n\nCode\ndata_tte &lt;- data_pop_mi |&gt; \n  select(id, index_date) |&gt; \n  left_join(basic_data |&gt; select(id, sex, death_date), by = \"id\")\n\ndata_tte\n\n\n# A tibble: 4,000 × 4\n   id    index_date sex   death_date\n   &lt;fct&gt; &lt;date&gt;     &lt;fct&gt; &lt;date&gt;    \n 1 212   2014-07-18 1     NA        \n 2 483   2017-12-10 2     NA        \n 3 731   2023-07-27 2     NA        \n 4 949   2021-11-03 1     NA        \n 5 981   2020-08-05 2     NA        \n 6 982   2015-05-22 2     NA        \n 7 1123  2015-07-25 1     NA        \n 8 2166  2016-09-30 1     NA        \n 9 2469  2023-08-26 2     2024-04-23\n10 2870  2010-09-03 1     NA        \n# ℹ 3,990 more rows\n\n\n\n\n9.4.2 Step 02: Generate stop dates\n\n\nCode\ndata_tte &lt;- data_tte |&gt; \n  dplyr::mutate(\n    max_fu = lubridate::ymd(index_date) + lubridate::years(1), # 1 year of follow-up\n    stop_study = lubridate::ymd(\"2024-12-31\")) # stop of study\n\ndata_tte\n\n\n# A tibble: 4,000 × 6\n   id    index_date sex   death_date max_fu     stop_study\n   &lt;fct&gt; &lt;date&gt;     &lt;fct&gt; &lt;date&gt;     &lt;date&gt;     &lt;date&gt;    \n 1 212   2014-07-18 1     NA         2015-07-18 2024-12-31\n 2 483   2017-12-10 2     NA         2018-12-10 2024-12-31\n 3 731   2023-07-27 2     NA         2024-07-27 2024-12-31\n 4 949   2021-11-03 1     NA         2022-11-03 2024-12-31\n 5 981   2020-08-05 2     NA         2021-08-05 2024-12-31\n 6 982   2015-05-22 2     NA         2016-05-22 2024-12-31\n 7 1123  2015-07-25 1     NA         2016-07-25 2024-12-31\n 8 2166  2016-09-30 1     NA         2017-09-30 2024-12-31\n 9 2469  2023-08-26 2     2024-04-23 2024-08-26 2024-12-31\n10 2870  2010-09-03 1     NA         2011-09-03 2024-12-31\n# ℹ 3,990 more rows\n\n\n\n\n9.4.3 Step 03. Select first of death, max follow-up, or study stop\n\n\nCode\ndata_tte &lt;- data_tte |&gt; \n  mutate(across(c(death_date, max_fu, stop_study), ~ as.Date(.x)), # ensure that dates are &lt;date&gt; format\n         end_date = pmin(death_date, max_fu, stop_study, na.rm = TRUE) # Follow-up ends at death, 1 year, or study stop — whichever comes \n  )\n\ndata_tte\n\n\n# A tibble: 4,000 × 7\n   id    index_date sex   death_date max_fu     stop_study end_date  \n   &lt;fct&gt; &lt;date&gt;     &lt;fct&gt; &lt;date&gt;     &lt;date&gt;     &lt;date&gt;     &lt;date&gt;    \n 1 212   2014-07-18 1     NA         2015-07-18 2024-12-31 2015-07-18\n 2 483   2017-12-10 2     NA         2018-12-10 2024-12-31 2018-12-10\n 3 731   2023-07-27 2     NA         2024-07-27 2024-12-31 2024-07-27\n 4 949   2021-11-03 1     NA         2022-11-03 2024-12-31 2022-11-03\n 5 981   2020-08-05 2     NA         2021-08-05 2024-12-31 2021-08-05\n 6 982   2015-05-22 2     NA         2016-05-22 2024-12-31 2016-05-22\n 7 1123  2015-07-25 1     NA         2016-07-25 2024-12-31 2016-07-25\n 8 2166  2016-09-30 1     NA         2017-09-30 2024-12-31 2017-09-30\n 9 2469  2023-08-26 2     2024-04-23 2024-08-26 2024-12-31 2024-04-23\n10 2870  2010-09-03 1     NA         2011-09-03 2024-12-31 2011-09-03\n# ℹ 3,990 more rows\n\n\n\n\n9.4.4 Step 04. Create a time indicator\n\n\nCode\ndata_tte &lt;- data_tte |&gt; \n  mutate(\n         time = as.numeric(end_date - index_date) # here in days\n         )\n\ndata_tte\n\n\n# A tibble: 4,000 × 8\n   id    index_date sex   death_date max_fu     stop_study end_date    time\n   &lt;fct&gt; &lt;date&gt;     &lt;fct&gt; &lt;date&gt;     &lt;date&gt;     &lt;date&gt;     &lt;date&gt;     &lt;dbl&gt;\n 1 212   2014-07-18 1     NA         2015-07-18 2024-12-31 2015-07-18   365\n 2 483   2017-12-10 2     NA         2018-12-10 2024-12-31 2018-12-10   365\n 3 731   2023-07-27 2     NA         2024-07-27 2024-12-31 2024-07-27   366\n 4 949   2021-11-03 1     NA         2022-11-03 2024-12-31 2022-11-03   365\n 5 981   2020-08-05 2     NA         2021-08-05 2024-12-31 2021-08-05   365\n 6 982   2015-05-22 2     NA         2016-05-22 2024-12-31 2016-05-22   366\n 7 1123  2015-07-25 1     NA         2016-07-25 2024-12-31 2016-07-25   366\n 8 2166  2016-09-30 1     NA         2017-09-30 2024-12-31 2017-09-30   365\n 9 2469  2023-08-26 2     2024-04-23 2024-08-26 2024-12-31 2024-04-23   241\n10 2870  2010-09-03 1     NA         2011-09-03 2024-12-31 2011-09-03   365\n# ℹ 3,990 more rows\n\n\nYou wish to check some restrictions:\n\n\nCode\n# No negative time values\ndata_tte |&gt; \n  filter(time &lt; 0 )\n\n\n# A tibble: 0 × 8\n# ℹ 8 variables: id &lt;fct&gt;, index_date &lt;date&gt;, sex &lt;fct&gt;, death_date &lt;date&gt;,\n#   max_fu &lt;date&gt;, stop_study &lt;date&gt;, end_date &lt;date&gt;, time &lt;dbl&gt;\n\n\nCode\n# Max follow-up time\ndata_tte |&gt; \n  filter(time == max(time)) |&gt; \n  select(time) |&gt; \n  distinct()\n\n\n# A tibble: 1 × 1\n   time\n  &lt;dbl&gt;\n1   366\n\n\nCode\n# Max date of stop\ndata_tte |&gt; \n  filter(end_date == max(end_date)) |&gt; \n  select(end_date) |&gt; \n  distinct()\n\n\n# A tibble: 1 × 1\n  end_date  \n  &lt;date&gt;    \n1 2024-12-31\n\n\n\n\n9.4.5 Step 05. Create a status indicator\n\n\nCode\ndata_tte &lt;- data_tte |&gt; \n  mutate(\n         status = \n           case_when(\n             !is.na(death_date) & death_date == end_date ~ 1, # if stop of follow-up due to death\n             TRUE ~ 0 # if censored due to 1 year of follow-up or study stop\n             )\n         ) |&gt; \n  select(-c(max_fu, stop_study))\n\ndata_tte\n\n\n# A tibble: 4,000 × 7\n   id    index_date sex   death_date end_date    time status\n   &lt;fct&gt; &lt;date&gt;     &lt;fct&gt; &lt;date&gt;     &lt;date&gt;     &lt;dbl&gt;  &lt;dbl&gt;\n 1 212   2014-07-18 1     NA         2015-07-18   365      0\n 2 483   2017-12-10 2     NA         2018-12-10   365      0\n 3 731   2023-07-27 2     NA         2024-07-27   366      0\n 4 949   2021-11-03 1     NA         2022-11-03   365      0\n 5 981   2020-08-05 2     NA         2021-08-05   365      0\n 6 982   2015-05-22 2     NA         2016-05-22   366      0\n 7 1123  2015-07-25 1     NA         2016-07-25   366      0\n 8 2166  2016-09-30 1     NA         2017-09-30   365      0\n 9 2469  2023-08-26 2     2024-04-23 2024-04-23   241      1\n10 2870  2010-09-03 1     NA         2011-09-03   365      0\n# ℹ 3,990 more rows\n\n\n\n\n9.4.6 Step 06. Fit the model\n\n\nCode\nfit_km &lt;- survfit(Surv(time, status) ~ sex, data = data_tte)\n\n\n\n\n9.4.7 Step 07. Check the output\nYou may wish to check the output at certain time points\n\n\nCode\ntime_points &lt;- c(0, 30, 30*3, 30*6, 30*9, 30*12)\n\nprint(summary(fit_km, times = time_points))\n\n\nCall: survfit(formula = Surv(time, status) ~ sex, data = data_tte)\n\n                sex=1 \n time n.risk n.event survival std.err lower 95% CI upper 95% CI\n    0   2500       0    1.000 0.00000        1.000        1.000\n   30   2185     304    0.878 0.00655        0.865        0.891\n   90   2115      44    0.860 0.00695        0.847        0.874\n  180   2018      68    0.832 0.00750        0.818        0.847\n  270   1947      44    0.814 0.00782        0.799        0.830\n  360   1870      46    0.795 0.00814        0.779        0.811\n\n                sex=2 \n time n.risk n.event survival std.err lower 95% CI upper 95% CI\n    0   1500       0    1.000 0.00000        1.000        1.000\n   30   1332     160    0.893 0.00799        0.878        0.909\n   90   1289      26    0.875 0.00855        0.859        0.892\n  180   1251      22    0.860 0.00898        0.843        0.878\n  270   1211      21    0.846 0.00937        0.828        0.864\n  360   1178      17    0.834 0.00968        0.815        0.853\n\n\n\n\n9.4.8 Step 08. Plot, quick and dirty\nYou can plot the Kaplan-Meier curve very easy with ggsurvfit. You can customise with ggplot2.\n\n\nCode\nggsurvfit(fit_km) + \n  add_confidence_interval() + \n  add_risktable() + \n  add_quantile(y_value = 0.6, color = \"gray50\", linewidth = 0.75) +\n  scale_ggsurvfit()\n\n\n\n\n\n\n\n\n\n\n\n9.4.9 Step 09. Alternative plotting\nThere are several different ways to do this. Probably also some more elegant ways.\nNow, we will store the output from the fit_km object in a format allowing us to extract results - and plot the risk curves\n\n9.4.9.1 Generate data\n\n\nCode\nmax_fu &lt;- max(data_tte$time)\ns_fit &lt;- summary(fit_km, times = 0:max_fu)\n\nround_function &lt;- function(x){\n  ifelse(x &gt;= 10,\n         sprintf(\"%.1f\", x), # 1 digit if 10 or higher\n         sprintf(\"%.2f\", x)) # 2 digits if lower\n}\n\ndata_mortality &lt;- data.frame(\n  time       = s_fit$time,\n  n_risk     = s_fit$n.risk,\n  n_event    = s_fit$n.event,\n  surv       = s_fit$surv,\n  strata     = s_fit$strata,\n  upper      = s_fit$upper,\n  lower      = s_fit$lower\n) |&gt; \n  mutate(\n    group = dplyr::case_when(\n      strata == \"sex=1\" ~ \"Male\",\n      strata == \"sex=2\" ~ \"Female\"\n      ),\n    group = factor(group, levels = c(\"Male\", \"Female\")),\n    risk_crude = (1-surv)*100,\n    ll_crude = (1-upper)*100,\n    ul_crude = (1-lower)*100\n  ) |&gt; \n  select(-c(strata, surv, upper, lower)) |&gt; \n  mutate(\n    across(\n      c(\n        risk_crude, ll_crude, ul_crude\n      ),\n      ~ round_function(.x)\n    )\n  )\n\nhead(data_mortality,20)\n\n\n   time n_risk n_event group risk_crude ll_crude ul_crude\n1     0   2500       0  Male       0.00     0.00     0.00\n2     1   2500      18  Male       0.72     0.39     1.05\n3     2   2482      23  Male       1.64     1.14     2.14\n4     3   2458      14  Male       2.20     1.62     2.77\n5     4   2444      21  Male       3.04     2.37     3.71\n6     5   2422      22  Male       3.92     3.16     4.68\n7     6   2400      18  Male       4.64     3.81     5.46\n8     7   2381      16  Male       5.28     4.40     6.16\n9     8   2365      11  Male       5.72     4.81     6.63\n10    9   2353      25  Male       6.72     5.74     7.70\n11   10   2327      21  Male       7.57     6.52     8.60\n12   11   2306       6  Male       7.81     6.75     8.85\n13   12   2299       7  Male       8.09     7.01     9.15\n14   13   2292       5  Male       8.29     7.20     9.36\n15   14   2286       2  Male       8.37     7.28     9.45\n16   15   2284      12  Male       8.85     7.73     9.96\n17   16   2272       6  Male       9.09     7.96     10.2\n18   17   2266       4  Male       9.25     8.11     10.4\n19   18   2261       7  Male       9.53     8.37     10.7\n20   19   2253      10  Male       9.93     8.75     11.1\n\n\n\n\n9.4.9.2 Extract results\nExtract results and print in different formats\n\n\nCode\nresults_mortality &lt;- \n  data_mortality |&gt; \n  filter(time %in% time_points,\n         time != 0) |&gt; \n  select(time, group, risk_crude, ll_crude, ul_crude)\n\nresults_mortality\n\n\n   time  group risk_crude ll_crude ul_crude\n1    30   Male       12.2     10.9     13.5\n2    90   Male       14.0     12.6     15.3\n3   180   Male       16.8     15.3     18.2\n4   270   Male       18.6     17.0     20.1\n5   360   Male       20.5     18.9     22.1\n6    30 Female       10.7     9.12     12.2\n7    90 Female       12.5     10.8     14.1\n8   180 Female       14.0     12.2     15.7\n9   270 Female       15.4     13.6     17.2\n10  360 Female       16.6     14.7     18.5\n\n\nCode\nresults_mortality |&gt; \n  pivot_wider(\n    names_from = time,\n    values_from = c(risk_crude, ll_crude, ul_crude)\n  ) |&gt; \n  select(group, ends_with(\"_30\"), ends_with(\"_90\"), ends_with(\"_180\"), ends_with(\"_270\"), ends_with(\"_360\")) |&gt; \nmutate(\n    risk_30 = glue(\"{risk_crude_30} ({ll_crude_30}–{ul_crude_30})\"),\n    risk_90 = glue(\"{risk_crude_90} ({ll_crude_90}–{ul_crude_90})\"),\n    risk_180 = glue(\"{risk_crude_180} ({ll_crude_180}–{ul_crude_180})\"),\n    risk_270 = glue(\"{risk_crude_270} ({ll_crude_270}–{ul_crude_270})\"),\n    risk_360 = glue(\"{risk_crude_360} ({ll_crude_360}–{ul_crude_360})\")\n  ) |&gt;\n  select(group, risk_30, risk_90, risk_180, risk_270, risk_360)\n\n\n# A tibble: 2 × 6\n  group  risk_30          risk_90          risk_180         risk_270    risk_360\n  &lt;fct&gt;  &lt;glue&gt;           &lt;glue&gt;           &lt;glue&gt;           &lt;glue&gt;      &lt;glue&gt;  \n1 Male   12.2 (10.9–13.5) 14.0 (12.6–15.3) 16.8 (15.3–18.2) 18.6 (17.0… 20.5 (1…\n2 Female 10.7 (9.12–12.2) 12.5 (10.8–14.1) 14.0 (12.2–15.7) 15.4 (13.6… 16.6 (1…\n\n\n\n\n9.4.9.3 Plot\n\n\nCode\nplot_mortality &lt;- \ndata_mortality |&gt;\n  mutate(across(c(risk_crude, time, ll_crude, ul_crude), ~ as.numeric(.x))) |&gt; \n  ggplot(aes(y = risk_crude, x = time, group = group, col = group, fill = group, ymin = ll_crude, ymax = ul_crude)) +\n  geom_line(show_legend = T, linewidth = .8) +\n  geom_ribbon(alpha = .25, col = NA, linetype = 0, show.legend = F) +\n  ggsci::scale_color_nejm() +\n  ggsci::scale_fill_nejm() +\n  scale_x_continuous(\n    name = \"Time since diagnosis (months)\",\n    expand = c(0, 0),\n    limits = c(0, 30*12),\n    breaks = seq(0, 30*12, 30*3),\n    labels = seq(0, 12, 3)\n  ) +\n  scale_y_continuous(\n    name = \"Absolute mortality risk (%)\",\n    limits = c(0, 30),\n    expand = c(0, 0),\n    breaks = seq(0, 30, 5),\n    labels = seq(0, 30, 5)\n  ) +\n  ggpubr::theme_classic2() +\n  theme(\n    plot.margin = margin(t = 0.5, r = 0.5, b = 0.5, l = 0.5, unit = \"cm\"),\n    text = element_text(family = \"serif\", size = 10),\n    axis.line = element_line(linewidth = .35),\n    axis.ticks = element_line(linewidth = .35),\n    axis.ticks.length = unit(.2, \"cm\"),\n    axis.title.x = element_text(face = \"bold\"),\n    axis.title.y = element_text(face = \"bold\", margin = margin(r = 7)),\n    legend.title = element_blank(),\n    legend.text = element_text(size = 10),\n    legend.position = c(.9, .9)\n  )\n\nplot_mortality\n\n\n\n\n\n\n\n\n\nAdding a risk table can be quite cumbersome but is doable. But we will not look into that for now.\n\n\n\n9.4.10 Step 10. Save the results\n\n9.4.10.1 Results\n\n\nCode\nwrite_xlsx(results_mortality, here::here(\"results/results_mortality.xlsx\"))\n\n\n\n\n9.4.10.2 Plot\nYou can save the ggplot2 object through the save function in he Plots viewer. However, you can also do it using ggsave.\n\n\nCode\nggsave(\n  filename = here::here(\"results/plot_mortality.pdf\"),\n  plot = plot_mortality,\n  device = cairo_pdf,\n  width = 8,\n  height = 6,\n  units = \"in\",\n  dpi = 600\n)",
    "crumbs": [
      "Sessions",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Time-to-event setup</span>"
    ]
  }
]